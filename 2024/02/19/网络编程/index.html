<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="网络编程day1笔记协议：    一组规则。 分层模型结构： 123456OSI七层模型：  物、数、网、传、会、表、应TCP&#x2F;IP 4层模型：网（链路层&#x2F;网络接口层）、网、传、应	应用层：http、ftp、nfs、ssh、telnet。。。	传输层：TCP、UDP	网络层：IP、ICMP、IGMP	链路层：以太网帧协议、ARP  c&#x2F;s模型： 1client-server  b&amp;#x2">
<meta property="og:type" content="article">
<meta property="og:title" content="Luccas&#39; NoteBook">
<meta property="og:url" content="https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Luccas&#39; NoteBook">
<meta property="og:description" content="网络编程day1笔记协议：    一组规则。 分层模型结构： 123456OSI七层模型：  物、数、网、传、会、表、应TCP&#x2F;IP 4层模型：网（链路层&#x2F;网络接口层）、网、传、应	应用层：http、ftp、nfs、ssh、telnet。。。	传输层：TCP、UDP	网络层：IP、ICMP、IGMP	链路层：以太网帧协议、ARP  c&#x2F;s模型： 1client-server  b&amp;#x2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Users/Administrator/AppData/Roaming/Typora/typora-user-images/1708420606702.png">
<meta property="og:image" content="https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Users/Administrator/AppData/Roaming/Typora/typora-user-images/1708400293830.png">
<meta property="og:image" content="https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Users/Administrator/AppData/Roaming/Typora/typora-user-images/1708400261305.png">
<meta property="og:image" content="https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1527923816604.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/28009832/1686829237044-def92cbb-8132-46ba-8933-e67a6eff4278.png">
<meta property="article:published_time" content="2024-02-19T09:37:04.222Z">
<meta property="article:modified_time" content="2024-02-28T09:19:33.542Z">
<meta property="article:author" content="Luccas0320">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Users/Administrator/AppData/Roaming/Typora/typora-user-images/1708420606702.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Luccas&#39; NoteBook</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.0.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/01/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/12/31/%E5%B7%A5%E4%BA%BA%E5%AE%89%E5%85%A8%E5%B8%BD%E5%92%8C%E5%8F%8D%E5%85%89%E8%A1%A3%E7%9B%91%E6%B5%8B/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&text="><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&is_video=false&description="><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&name=&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&t="><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#day1%E7%AC%94%E8%AE%B0"><span class="toc-number">1.1.</span> <span class="toc-text">day1笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket"><span class="toc-number">1.2.</span> <span class="toc-text">socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">四次握手  断开连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">三次握手与函数的对应关系：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8ETCP%E7%8A%B6%E6%80%81%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.2.4.</span> <span class="toc-text">三次握手四次挥手与TCP状态对应关系：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%EF%BC%9A"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">端口复用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E5%8C%85%EF%BC%9A"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">心跳包：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E5%85%B3%E9%97%AD%E7%AB%AF%E7%9A%842MSL%E6%97%B6%E9%95%BF%EF%BC%9A"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">主动关闭端的2MSL时长：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="toc-number">1.2.5.</span> <span class="toc-text">半关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#day2%E7%AC%94%E8%AE%B0"><span class="toc-number">1.3.</span> <span class="toc-text">day2笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">多路IO转接（响应式）服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">select函数实现响应式服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">select函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9B%86%E5%90%88%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">设置集合的函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">思路分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">select实现代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">select优缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#day3%E7%AC%94%E8%AE%B0"><span class="toc-number">1.5.</span> <span class="toc-text">day3笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#poll%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">poll函数实现响应式服务器（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">poll函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">思路分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">poll实现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">poll优缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4-1024-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6%EF%BC%9A"><span class="toc-number">1.5.1.4.1.</span> <span class="toc-text">突破 1024 文件描述符限制：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">epoll函数实现响应式服务器（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">epoll函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">epoll实现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E7%9A%84%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">epoll的触发模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readn%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">readn阻塞：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E5%9C%A8ET%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8fcntl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-number">1.5.2.5.1.</span> <span class="toc-text">如果要在ET的情况下用fcntl函数实现非阻塞：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-number">1.5.2.5.1.1.</span> <span class="toc-text">设置阻塞非阻塞：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">epoll优缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">epoll反应堆模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#day4%E7%AC%94%E8%AE%B0"><span class="toc-number">1.6.</span> <span class="toc-text">day4笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.7.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.7.1.</span> <span class="toc-text">线程池的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">线程池相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.7.3.</span> <span class="toc-text">线程池模块分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.7.4.</span> <span class="toc-text">实现代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E5%92%8CUDP%E9%80%9A%E4%BF%A1%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">TCP通信和UDP通信各自的优缺点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="toc-number">1.9.</span> <span class="toc-text">UDP通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%AE%9E%E7%8E%B0%E7%9A%84-C-S-%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.9.1.</span> <span class="toc-text">UDP实现的 C&#x2F;S 模型：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">服务器代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">客户端代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.10.</span> <span class="toc-text">本地套接字和网络套接字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">1.11.</span> <span class="toc-text">IPC通信：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">1.12.</span> <span class="toc-text">网络通信：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Libevent%E5%BA%93"><span class="toc-number">1.13.</span> <span class="toc-text">Libevent库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AF%B9%E6%AF%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-TCP-C-S%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.13.1.</span> <span class="toc-text">本地套接字对比网络编程 TCP C&#x2F;S模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.13.2.</span> <span class="toc-text">实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">服务器代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">客户端代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libevent%E5%BA%93"><span class="toc-number">1.14.</span> <span class="toc-text">libevent库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-README%E3%80%81readme"><span class="toc-number">1.14.1.</span> <span class="toc-text">参考 README、readme</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.14.2.</span> <span class="toc-text">特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">同步&#x2F;异步通信模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%86%B3%E5%92%8C%E9%9D%9E%E6%9C%AA%E5%86%B3%EF%BC%9A"><span class="toc-number">1.14.3.</span> <span class="toc-text">未决和非未决：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BA%8B%E4%BB%B6-bufferevent"><span class="toc-number">1.14.4.</span> <span class="toc-text">带缓冲区的事件 bufferevent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bufferevent%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.5.</span> <span class="toc-text">bufferevent相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.14.6.</span> <span class="toc-text">启动和关闭缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%A4%A7%E7%BB%83%E4%B9%A0"><span class="toc-number">1.15.</span> <span class="toc-text">web大练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%9Ahtml%E8%AF%AD%E8%A8%80"><span class="toc-number">1.15.1.</span> <span class="toc-text">准备工作：html语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.15.2.</span> <span class="toc-text">http超文本传输协议</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Luccas0320</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-02-19T09:37:04.222Z" class="dt-published" itemprop="datePublished">2024-02-19</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="day1笔记"><a href="#day1笔记" class="headerlink" title="day1笔记"></a>day1笔记</h2><p>协议：<br>    一组规则。</p>
<p>分层模型结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OSI七层模型：  物、数、网、传、会、表、应</span><br><span class="line">TCP/IP 4层模型：网（链路层/网络接口层）、网、传、应</span><br><span class="line">	应用层：http、ftp、nfs、ssh、telnet。。。</span><br><span class="line">	传输层：TCP、UDP</span><br><span class="line">	网络层：IP、ICMP、IGMP</span><br><span class="line">	链路层：以太网帧协议、ARP</span><br></pre></td></tr></table></figure>

<p>c&#x2F;s模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-server</span><br></pre></td></tr></table></figure>

<p>b&#x2F;s模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">browser-server</span><br><span class="line">		C/S					B/S</span><br><span class="line"></span><br><span class="line">优点：	缓存大量数据、协议选择灵活			安全性、跨平台、开发工作量较小</span><br><span class="line"></span><br><span class="line">	速度快</span><br><span class="line"></span><br><span class="line">缺点：	安全性、跨平台、开发工作量较大			不能缓存大量数据、严格遵守 http</span><br></pre></td></tr></table></figure>

<p>网络传输流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据没有封装之前，是不能在网络中传递。</span><br><span class="line">数据-》应用层-》传输层-》网络层-》链路层  --- 网络环境</span><br><span class="line">以太网帧协议：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARP协议：根据 Ip 地址获取 mac 地址。</span><br><span class="line"></span><br><span class="line">以太网帧协议：根据mac地址，完成数据包传输。</span><br></pre></td></tr></table></figure>

<p>IP协议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">版本： IPv4、IPv6  -- 4位</span><br><span class="line"></span><br><span class="line">TTL： time to live 。 设置数据包在路由节点中的跳转上限。每经过一个路由节点，该值-1， 减为0的路由，有义务将该数据包丢弃</span><br><span class="line"></span><br><span class="line">源IP： 32位。--- 4字节		192.168.1.108 --- 点分十进制 IP地址（string）  --- 二进制 </span><br><span class="line"></span><br><span class="line">目的IP：32位。--- 4字节</span><br></pre></td></tr></table></figure>

<p>IP地址：可以在网络环境中，唯一标识一台主机。</p>
<p>端口号：可以网络的一台主机上，唯一标识一个进程。</p>
<p>ip地址+端口号：可以在网络环境中，唯一标识一个进程。</p>
<p>UDP：<br>    16位：源端口号。	2^16 &#x3D; 65536  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16位：目的端口号。</span><br></pre></td></tr></table></figure>

<p>TCP协议：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">16位：源端口号。	2^16 = 65536  </span><br><span class="line">16位：目的端口号。</span><br><span class="line">32序号;</span><br><span class="line">32确认序号。	</span><br><span class="line">6个标志位。</span><br><span class="line">16位窗口大小。	2^16 = 65536 </span><br></pre></td></tr></table></figure>

<p>网络套接字：  socket</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个文件描述符指向一个套接字（该套接字内部由内核借助两个缓冲区实现。）</span><br><span class="line">在通信过程中， 套接字一定是成对出现的。</span><br></pre></td></tr></table></figure>

<p>网络字节序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小端法：（pc本地存储）	高位存高地址。地位存低地址。	int a = 0x12345678</span><br><span class="line">大端法：（网络存储）	高位存低地址。地位存高地址。</span><br><span class="line">htonl --&gt; 本地--》网络 （IP）			192.168.1.11 --&gt; string --&gt; atoi --&gt; int --&gt; htonl --&gt; 网络字节序</span><br><span class="line">htons --&gt; 本地--》网络 (port)</span><br><span class="line">ntohl --&gt; 网络--》 本地（IP）</span><br><span class="line">ntohs --&gt; 网络--》 本地（Port）</span><br></pre></td></tr></table></figure>

<p>IP地址转换函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int inet_pton(int af, const char *src, void *dst);		本地字节序（string IP） ---&gt; 网络字节序</span><br><span class="line">	af：AF_INET、AF_INET6</span><br><span class="line">	src：传入，IP地址（点分十进制）</span><br><span class="line">	dst：传出，转换后的 网络字节序的 IP地址。 </span><br><span class="line">	返回值：</span><br><span class="line">		成功： 1</span><br><span class="line">		异常： 0， 说明src指向的不是一个有效的ip地址。</span><br><span class="line">		失败：-1</span><br><span class="line">   const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);	网络字节序 ---&gt; 本地字节序（string IP）</span><br><span class="line">	af：AF_INET、AF_INET6</span><br><span class="line">	src: 网络字节序IP地址</span><br><span class="line">	dst：本地字节序（string IP）</span><br><span class="line">	size： dst 的大小。</span><br><span class="line">	返回值： 成功：dst。 	</span><br><span class="line">		失败：NULL</span><br></pre></td></tr></table></figure>

<p>sockaddr地址结构：	IP + port	–&gt; 在网络环境中唯一标识一个进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in addr;</span><br><span class="line">addr.sin_family = AF_INET/AF_INET6				man 7 ip</span><br><span class="line">addr.sin_port = htons(9527);</span><br><span class="line">	int dst;</span><br><span class="line">	inet_pton(AF_INET, &quot;192.157.22.45&quot;, (void *)&amp;dst);</span><br><span class="line">addr.sin_addr.s_addr = dst;</span><br><span class="line">【*】addr.sin_addr.s_addr = htonl(INADDR_ANY);		取出系统中有效的任意IP地址。二进制类型。</span><br><span class="line">bind(fd, (struct sockaddr *)&amp;addr, size);</span><br></pre></td></tr></table></figure>

<p>socket函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);		创建一个 套接字</span><br><span class="line">	domain：AF_INET、AF_INET6、AF_UNIX</span><br><span class="line">	type：SOCK_STREAM、SOCK_DGRAM</span><br><span class="line">	protocol: 0 </span><br><span class="line">	返回值：</span><br><span class="line">		成功： 新套接字所对应文件描述符</span><br><span class="line">		失败: -1 errno</span><br><span class="line"> #include &lt;arpa/inet.h&gt;</span><br><span class="line"> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);		给socket绑定一个 地址结构 (IP+port)</span><br><span class="line">	sockfd: socket 函数返回值</span><br><span class="line">		struct sockaddr_in addr;</span><br><span class="line">		addr.sin_family = AF_INET;</span><br><span class="line">		addr.sin_port = htons(8888);</span><br><span class="line">		addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	addr: 传入参数(struct sockaddr *)&amp;addr</span><br><span class="line">	addrlen: sizeof(addr) 地址结构的大小。</span><br><span class="line">	返回值：</span><br><span class="line">		成功：0</span><br><span class="line">		失败：-1 errno</span><br><span class="line">int listen(int sockfd, int backlog);		设置同时与服务器建立连接的上限数。（同时进行3次握手的客户端数量）</span><br><span class="line">	sockfd: socket 函数返回值</span><br><span class="line">	backlog：上限数值。最大值 128.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	返回值：</span><br><span class="line">		成功：0</span><br><span class="line">		失败：-1 errno	</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);	阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符。</span><br><span class="line">	sockfd: socket 函数返回值</span><br><span class="line">	addr：传出参数。成功与服务器建立连接的那个客户端的地址结构（IP+port）</span><br><span class="line">		socklen_t clit_addr_len = sizeof(addr);</span><br><span class="line">	addrlen：传入传出。 &amp;clit_addr_len</span><br><span class="line">		 入：addr的大小。 出：客户端addr实际大小。</span><br><span class="line">	返回值：</span><br><span class="line">		成功：能与客户端进行数据通信的 socket 对应的文件描述。</span><br><span class="line">		失败： -1 ， errno</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);	  使用现有的 socket 与服务器建立连接</span><br><span class="line">sockfd： socket 函数返回值</span><br><span class="line">	struct sockaddr_in srv_addr;		// 服务器地址结构</span><br><span class="line">	srv_addr.sin_family = AF_INET;</span><br><span class="line">	srv_addr.sin_port = 9527 	跟服务器bind时设定的 port 完全一致。</span><br><span class="line">	inet_pton(AF_INET, &quot;服务器的IP地址&quot;，&amp;srv_adrr.sin_addr.s_addr);</span><br><span class="line">addr：传入参数。服务器的地址结构</span><br></pre></td></tr></table></figure>

<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addrlen：服务器的地址结构的大小</span><br><span class="line">返回值：</span><br><span class="line">	成功：0</span><br><span class="line">	失败：-1 errno</span><br><span class="line">如果不使用bind绑定客户端地址结构, 采用&quot;隐式绑定&quot;.</span><br></pre></td></tr></table></figure>

<p>TCP通信流程分析:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">	1. socket()	创建socket</span><br><span class="line">	2. bind()	绑定服务器地址结构</span><br><span class="line">	3. listen()	设置监听上限</span><br><span class="line">	4. accept()	阻塞监听客户端连接</span><br><span class="line">	5. read(fd)	读socket获取客户端数据</span><br><span class="line">	6. 小--大写	toupper()</span><br><span class="line">	7. write(fd)</span><br><span class="line">	8. close();</span><br><span class="line"></span><br><span class="line">client:</span><br><span class="line">	1. socket()	创建socket</span><br><span class="line">	2. connect();	与服务器建立连接</span><br><span class="line">	3. write()	写数据到 socket</span><br><span class="line">	4. read()	读转换后的数据。</span><br><span class="line">	5. 显示读取结果</span><br><span class="line">	6. close()</span><br></pre></td></tr></table></figure>

<p>​		</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p><img src="/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Users\Administrator\AppData\Roaming\Typora\typora-user-images\1708420606702.png" alt="1708420606702"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"><span class="comment">//服务器代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>, cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clit_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clit_addr_len;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//建立socket</span></span><br><span class="line">    lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bind 绑定ip+port</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="comment">//listen 设置监听上限</span></span><br><span class="line">    listen(lfd,<span class="number">128</span>);</span><br><span class="line">    clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">    <span class="comment">//accept 阻塞直到有客户端数据连接</span></span><br><span class="line">    cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;clit_addr, &amp;clit_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        write(cfd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(lfd);</span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个窗口</p>
<p><img src="/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Users\Administrator\AppData\Roaming\Typora\typora-user-images\1708400293830.png" alt="1708400293830"></p>
<p>第二个窗口</p>
<p> nc 127.0.0.1 9527 客户端向服务器发送信息</p>
<p><img src="/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Users\Administrator\AppData\Roaming\Typora\typora-user-images\1708400261305.png" alt="1708400261305"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"><span class="comment">//服务器代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(str); <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>, cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ],client_IP[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clit_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clit_addr_len;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//建立socket</span></span><br><span class="line">    lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bind 绑定ip+port</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="comment">//listen 设置监听上限</span></span><br><span class="line">    listen(lfd,<span class="number">128</span>);</span><br><span class="line">    clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">    <span class="comment">//accept 阻塞直到有客户端数据连接</span></span><br><span class="line">    cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;clit_addr, &amp;clit_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//与客户端成功建立连接之后把客户端的地址和端口号打印出来</span></span><br><span class="line">    <span class="comment">//客户端地址从本地形式转为网络形式传给服务器，现在需要转换位本地形式</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip:%s port:%d\n&quot;</span>,inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP)),ntohs(clit_addr.sin_port));</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        write(cfd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(lfd);</span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">    <span class="type">int</span> conter = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>          <span class="comment">//服务器地址结构</span></span><br><span class="line"></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="comment">//inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr);</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;connect err&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--conter) &#123;</span><br><span class="line">        write(cfd, <span class="string">&quot;hello\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        ret = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>三次握手 建立连接</p>
<p>![1708422833527](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708422833527.png)</p>
<p>![1708422817941](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708422817941.png)</p>
<h3 id="四次握手-断开连接"><a href="#四次握手-断开连接" class="headerlink" title="四次握手  断开连接"></a>四次握手  断开连接</h3><p>![1708431321844](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708431321844.png)</p>
<p>导致四次握手才能断开连接的原因是什么：半关闭</p>
<p>每个socket套接字里面有两个缓冲区：写数据的缓冲区和都数据的缓冲区，</p>
<p>在客户端发送FIN信号之后，服务器端同意了，然后客户端关闭自己的写缓冲区，但是连接还是存在的，它可以发送不在写缓冲区的信号，比如在TCP头部的ACK信号</p>
<p>![1708431678033](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708431678033.png)</p>
<blockquote>
<p>客户端：我不说话啦？</p>
<p>服务器：嗯</p>
<p>客户端：闭上了自己的嘴（但是两人的电话还没挂断）</p>
</blockquote>
<p>除了SYN、ACK、FIN信号，还有一个滑动窗口win：用来告诉对方我能接收的最大数据是多少，够了这个数据就不要发了</p>
<p>![1708432554044](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708432554044.png)</p>
<p>这里假定左边是客户端右边是服务器，客户端是4096服务器是4144，发到第9个就不再发了，因为客户端发到第9个已经发了5121+1024-1&#x3D;6144了，再发就超了</p>
<p>![1708432889242](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708432889242.png)</p>
<p>然后后面服务器不断处理读缓冲区的数据，从6144-6144&#x3D;0变为2048再变为4096</p>
<p>滑动窗口就是为了防止数据丢失</p>
<h3 id="三次握手与函数的对应关系："><a href="#三次握手与函数的对应关系：" class="headerlink" title="三次握手与函数的对应关系："></a>三次握手与函数的对应关系：</h3><p>![1708435420246](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708435420246.png)</p>
<h3 id="三次握手四次挥手与TCP状态对应关系："><a href="#三次握手四次挥手与TCP状态对应关系：" class="headerlink" title="三次握手四次挥手与TCP状态对应关系："></a>三次握手四次挥手与TCP状态对应关系：</h3><p>（参考上面那张图好看）</p>
<p>![1708501001865](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708501001865.png)</p>
<p>三次握手四次挥手与TCP状态对应关系</p>
<p>![1708502991908](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708502991908.png)</p>
<p>只有主动关闭连接这一方会经历FIN_WAIT2（半关闭）和TIME_WAIT状态和2MSL时长才能关闭</p>
<p>只有被动关闭一方有CLOSE_WAIT，此时主动关闭一方处于版关闭状态</p>
<p>所以如果先关闭服务器，想要接着重启会报错Address is already in use，因为他是主动关闭连接一方正在等待2MSL时长，而如果先关闭客户端，因为他的端口是系统自动分配的不固定，所以没事</p>
<h4 id="端口复用："><a href="#端口复用：" class="headerlink" title="端口复用："></a>端口复用：</h4><p>服务器是在bind函数之前（可能客户端在connect函数之前）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,(<span class="type">void</span> *)&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<p>SO_REUSEADDR 端口复用</p>
<h4 id="心跳包："><a href="#心跳包：" class="headerlink" title="心跳包："></a>心跳包：</h4><p>如果对方异常断开，本机检测不到，一直等待，浪费资源，需要设置TCP的保持连接，作用就是每隔一定的时间间隔发送探测分节，如果连续发送多个探测分节对方还未回应，就将次连接断开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(lfd,SOL_SOCKET,SO_KEEPALIVE,(<span class="type">void</span> *)&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure>

<p>SO_KEEPALIVE表示保持连接，如果两个小时内这个套接字的口没有数据交换，发一次报文，对方如果不回复就自动关闭这个进程 </p>
<p>也可以不用SO_KEEPALIVE自己写一个规定时间</p>
<p>心跳包：最小粒度</p>
<p>乒乓包：携带比较多的数据的心跳包</p>
<h4 id="主动关闭端的2MSL时长："><a href="#主动关闭端的2MSL时长：" class="headerlink" title="主动关闭端的2MSL时长："></a>主动关闭端的2MSL时长：</h4><blockquote>
<p>保证最后一个ACK能成功被对端接收。(等待期间，对端没收到我发的ACK，对端会再次发送FIN请求。）</p>
</blockquote>
<h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><p>通信双方中，只有一端关闭通信。——FIN_WAIT_2</p>
<p>关闭使用close(cfd)或者shutdown(cfd,SHUT_RD)</p>
<p>两者的区别：</p>
<p>shutdown可以更精细的关闭写缓冲区或者读缓冲区</p>
<p>如果使用dup2(cfd,cfd1);</p>
<p>当使用close(cfd)之后虽然cfd关闭了但是cfd1还可以用</p>
<p>使用shutdown(cfd,SHUT_RD)cfd1也不能用了</p>
<h2 id="day2笔记"><a href="#day2笔记" class="headerlink" title="day2笔记"></a>day2笔记</h2><blockquote>
<p>三次握手：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主动发起连接请求端，发送 SYN 标志位，请求建立连接。 携带序号号、数据字节数(0)、滑动窗口大小。</span><br><span class="line"></span><br><span class="line">被动接受连接请求端，发送 ACK 标志位，同时携带 SYN 请求标志位。携带序号、确认序号、数据字节数(0)、滑动窗口大小。</span><br><span class="line"></span><br><span class="line">主动发起连接请求端，发送 ACK 标志位，应答服务器连接请求。携带确认序号。</span><br></pre></td></tr></table></figure>

<p>四次挥手：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主动关闭连接请求端， 发送 FIN 标志位。 </span><br><span class="line"></span><br><span class="line">被动关闭连接请求端， 应答 ACK 标志位。 		 ----- 半关闭完成。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被动关闭连接请求端， 发送 FIN 标志位。</span><br><span class="line"></span><br><span class="line">主动关闭连接请求端， 应答 ACK 标志位。		 ----- 连接全部关闭</span><br></pre></td></tr></table></figure>

<p>​	<br>滑动窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送给连接对端，本端的缓冲区大小（实时），保证数据不会丢失。</span><br></pre></td></tr></table></figure>

<p>错误处理函数： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">封装目的： </span><br><span class="line"></span><br><span class="line">	在 server.c 编程过程中突出逻辑，将出错处理与逻辑分开，可以直接跳转man手册。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【wrap.c】								【wrap.h】</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">存放网络通信相关常用 自定义函数						存放 网络通信相关常用 自定义函数原型(声明)。</span><br><span class="line"></span><br><span class="line">命名方式：系统调用函数首字符大写, 方便查看man手册</span><br><span class="line">	</span><br><span class="line">	  如：Listen()、Accept();</span><br><span class="line"></span><br><span class="line">函数功能：调用系统调用函数，处理出错场景。</span><br><span class="line"></span><br><span class="line">在 server.c 和 client.c 中调用 自定义函数</span><br><span class="line"></span><br><span class="line">联合编译 server.c 和 wrap.c 生成 server</span><br><span class="line"> </span><br><span class="line">	 client.c 和 wrap.c 生成 client</span><br></pre></td></tr></table></figure>

<p>readn：<br>    读 N 个字节</p>
<p>readline：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读一行</span><br></pre></td></tr></table></figure>

<p>read 函数的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. &gt; 0 实际读到的字节数</span><br><span class="line"></span><br><span class="line">2. = 0 已经读到结尾（对端已经关闭）【 ！重 ！点 ！】</span><br><span class="line"></span><br><span class="line">3. -1 应进一步判断errno的值：</span><br><span class="line"></span><br><span class="line">	errno = EAGAIN or EWOULDBLOCK: 设置了非阻塞方式 读。 没有数据到达。 </span><br><span class="line"></span><br><span class="line">	errno = EINTR 慢速系统调用被 中断。</span><br><span class="line"></span><br><span class="line">	errno = “其他情况” 异常。</span><br></pre></td></tr></table></figure>

<p>多进程并发服务器：server.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1. Socket();		创建 监听套接字 lfd</span><br><span class="line">2. Bind()	绑定地址结构 Strcut scokaddr_in addr;</span><br><span class="line">3. Listen();	</span><br><span class="line">4. while (1) &#123;</span><br><span class="line"></span><br><span class="line">	cfd = Accpet();			接收客户端连接请求。</span><br><span class="line">	pid = fork();</span><br><span class="line">	if (pid == 0)&#123;			子进程 read(cfd) --- 小-》大 --- write(cfd)</span><br><span class="line"></span><br><span class="line">		close(lfd)		关闭用于建立连接的套接字 lfd</span><br><span class="line"></span><br><span class="line">		read()</span><br><span class="line">		小--大</span><br><span class="line">		write()</span><br><span class="line"></span><br><span class="line">	&#125; else if （pid &gt; 0） &#123;	</span><br><span class="line"></span><br><span class="line">		close(cfd);		关闭用于与客户端通信的套接字 cfd	</span><br><span class="line">		contiue;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">5. 子进程：</span><br><span class="line"></span><br><span class="line">	close(lfd)</span><br><span class="line"></span><br><span class="line">	read()</span><br><span class="line"></span><br><span class="line">	小--大</span><br><span class="line"></span><br><span class="line">	write()	</span><br><span class="line"></span><br><span class="line">   父进程：</span><br><span class="line"></span><br><span class="line">	close(cfd);</span><br><span class="line"></span><br><span class="line">	注册信号捕捉函数：	SIGCHLD</span><br><span class="line"></span><br><span class="line">	在回调函数中， 完成子进程回收</span><br><span class="line"></span><br><span class="line">		while （waitpid()）;</span><br></pre></td></tr></table></figure>

<p>多线程并发服务器： server.c </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. Socket();		创建 监听套接字 lfd</span><br><span class="line"></span><br><span class="line">2. Bind()		绑定地址结构 Strcut scokaddr_in addr;</span><br><span class="line"></span><br><span class="line">3. Listen();		</span><br><span class="line"></span><br><span class="line">4. while (1) &#123;		</span><br><span class="line"></span><br><span class="line">	cfd = Accept(lfd, );</span><br><span class="line"></span><br><span class="line">	pthread_create(&amp;tid, NULL, tfn, (void *)cfd);</span><br><span class="line"></span><br><span class="line">	pthread_detach(tid);  				// pthead_join(tid, void **);  新线程---专用于回收子线程。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">5. 子线程：</span><br><span class="line"></span><br><span class="line">	void *tfn(void *arg) </span><br><span class="line">	&#123;</span><br><span class="line">		// close(lfd)			不能关闭。 主线程要使用lfd</span><br><span class="line"></span><br><span class="line">		read(cfd)</span><br><span class="line"></span><br><span class="line">		小--大</span><br><span class="line"></span><br><span class="line">		write(cfd)</span><br><span class="line"></span><br><span class="line">		pthread_exit（(void *)10）;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多路IO转接（响应式）服务器"><a href="#多路IO转接（响应式）服务器" class="headerlink" title="多路IO转接（响应式）服务器"></a>多路IO转接（响应式）服务器</h2><p>设计两个监听 lfd和cfd</p>
<p>lfd是系统创建的，创建好交给小秘书让他监听，是否有人跟我连接，如果有，再调用accept函数，这样accept不用一直处于阻塞状态</p>
<p>cfd监听是都进行数据通信</p>
<blockquote>
<p>过程：</p>
<p>如果有c2想向我连接，他先找小秘书，小秘书再找我，然后我调accept函数，就可以直接返回一个cfd2，不用阻塞等着,，然后产生的cfd2继续交给小秘书(select()函数)监听</p>
</blockquote>
<p>三种响应模式：</p>
<blockquote>
<p>响应式：上述带个秘书用来监听的模式（有学生听不懂问老师，老师再给解答）</p>
<p>阻塞式：一个进程在那里等着（老师问学生有没有听不懂，学生不回答，老师就一直等着）</p>
<p>非阻塞忙轮询：（老师问学生有没有听不懂，学生不回答，老师回去忙5分钟再去问学生）</p>
<p>小秘书有<code>poll()</code>，<code>epoll()</code>, <code>select()</code></p>
</blockquote>
<h3 id="select函数实现响应式服务器"><a href="#select函数实现响应式服务器" class="headerlink" title="select函数实现响应式服务器"></a>select函数实现响应式服务器</h3><h4 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h4><p>原理：  借助内核， select 来监听， 客户端连接、数据通信事件。</p>
<p><code>int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</code></p>
<blockquote>
<p>nfds：监听的所有文件描述符中，最大文件描述符+1</p>
<p>readfds： 读 文件描述符监听集合。  传入、传出参数</p>
<p>writefds：写 文件描述符监听集合。  传入、传出参数       NULL</p>
<p>exceptfds：异常 文件描述符监听集合 传入、传出参数       NULL</p>
<p>timeout：  &gt; 0:   设置监听超时时长。</p>
<p>​                    NULL:  阻塞监听</p>
<p>​                   0： 非阻塞监听，轮询</p>
<p>​       返回值：</p>
<p>​           &gt; 0:   所有监听集合（3个）中， 满足对应事件的总数。</p>
<p>​           0： 没有满足监听条件的文件描述符</p>
<p>​           -1：   errno</p>
<p>​			在执行完select函数之后，前面的文件描述符集合也会变化，变成发生事件的文件描述符，比如之前读事件描述符的输入3、4、5，发生读事件的是4、5，文件描述符就变成4、5</p>
</blockquote>
<p>![1708518269532](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708518269532.png)如图所示请求nfds&#x3D;6+1</p>
<p>如果有新的c4发出connect请求，就是让lfd发出读时间，这个select监听就是在监听这些文件描述符有没有读事件</p>
<p>原理：  借助内核， select 来监听， 客户端连接、数据通信事件。</p>
<h4 id="设置集合的函数："><a href="#设置集合的函数：" class="headerlink" title="设置集合的函数："></a>设置集合的函数：</h4><p>传入select的是文件描述符集合，因此要把需要监听的文件描述符加入集合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;	--- 清空一个文件描述符集合。</span><br><span class="line"></span><br><span class="line">	fd_set rset;</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;	--- 将待监听的文件描述符，添加到监听集合中</span><br><span class="line"></span><br><span class="line">	FD_SET(<span class="number">3</span>, &amp;rset);	FD_SET(<span class="number">5</span>, &amp;rset);	FD_SET(<span class="number">6</span>, &amp;rset);</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;	--- 将一个文件描述符从监听集合中 移除。</span><br><span class="line"></span><br><span class="line">	FD_CLR（<span class="number">4</span>， &amp;rset）;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;	--- 判断一个文件描述符是否在监听集合中。</span><br><span class="line"></span><br><span class="line">	返回值： 在：<span class="number">1</span>；不在：<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">	FD_ISSET（<span class="number">4</span>， &amp;rset）;</span><br></pre></td></tr></table></figure>
<h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>一般之考虑读事件，lfd连接请求是读事件，cfd读也是读事件</p>
<p>而cfd写事件一般不考虑，因为一般客户端请求连接接通之后，服务器向客户端写一般是都可以的，除了客户端发送FIN信号之后处于半关闭状态或者服务器写的太快了数据量超过滑动窗口的这两种情况</p>
<blockquote>
<p>int maxfd &#x3D; 0；</p>
<p>lfd &#x3D; socket() ;			创建套接字</p>
<p>maxfd &#x3D; lfd；</p>
<p>bind();					绑定地址结构</p>
<p>listen();				设置监听上限</p>
<p>fd_set rset， allset;			创建r监听集合，一个里面只有lfd，一个是lfd和后来select加上的cfd</p>
<p>FD_ZERO(&amp;allset);				将r监听集合清空</p>
<p>FD_SET(lfd, &amp;allset);			将 lfd 添加至读集合中。</p>
<p>while（1） {</p>
<pre><code>rset = allset；			保存监听集合

ret  = select(lfd+1， &amp;rset， NULL， NULL， NULL);		监听文件描述符集合对应事件。

if（ret &gt; 0） &#123;							有监听的描述符满足对应事件

    if (FD_ISSET(lfd, &amp;rset)) &#123;				// 1 在。 0不在。

        cfd = accept（）；				建立连接，返回用于通信的文件描述符

        maxfd = cfd；

        FD_SET(cfd, &amp;allset);				添加到监听通信描述符集合中。
    &#125;

    for （i = lfd+1； i &lt;= 最大文件描述符; i++）&#123;

        FD_ISSET(i, &amp;rset)				检测新加入的cfd是否有read、write事件

        read（）

        小 -- 大

        write();
    &#125;	
&#125;
</code></pre>
<p>}</p>
</blockquote>
<h4 id="select实现代码："><a href="#select实现代码：" class="headerlink" title="select实现代码："></a>select实现代码：</h4><p><code>F:\a语法基础\C++\Linux\linux网络编程资料\day3\4-源代码\select_concurrent</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, maxi;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nready, client[FD_SETSIZE];                 <span class="comment">/* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */</span></span><br><span class="line">    <span class="type">int</span> maxfd, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ], str[INET_ADDRSTRLEN];         <span class="comment">/* #define INET_ADDRSTRLEN 16 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>, <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clie_addr_len;</span><br><span class="line">    fd_set rset, allset;                            <span class="comment">/* rset 读事件文件描述符集合 allset用来暂存 */</span></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family= AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port= htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">    Bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    Listen(listenfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    maxfd = listenfd;                                           <span class="comment">/* 起初 listenfd 即为最大文件描述符 */</span></span><br><span class="line"></span><br><span class="line">    maxi = <span class="number">-1</span>;                                                  <span class="comment">/* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">        client[i] = <span class="number">-1</span>;                                         <span class="comment">/* 用-1初始化client[] */</span></span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);                                  <span class="comment">/* 构造select监控文件描述符集 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;   </span><br><span class="line">        rset = allset;                                          <span class="comment">/* 每次循环时都从新设置select监控信号集 */</span></span><br><span class="line"></span><br><span class="line">        nready = select(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">//2  1--lfd  1--connfd</span></span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">            perr_exit(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset)) &#123;                        <span class="comment">/* 说明有新的客户端链接请求 */</span></span><br><span class="line"></span><br><span class="line">            clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = Accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;clie_addr, &amp;clie_addr_len);       <span class="comment">/* Accept 不会阻塞 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                    inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">                    ntohs(clie_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">                <span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;                            <span class="comment">/* 找client[]中没有使用的位置 */</span></span><br><span class="line">                    client[i] = connfd;                         <span class="comment">/* 保存accept返回的文件描述符到client[]里 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == FD_SETSIZE) &#123;                              <span class="comment">/* 达到select能监控的文件个数上限 1024 */</span></span><br><span class="line">                <span class="built_in">fputs</span>(<span class="string">&quot;too many clients\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            FD_SET(connfd, &amp;allset);                            <span class="comment">/* 向监控文件描述符集合allset添加新的文件描述符connfd */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">                maxfd = connfd;                                 <span class="comment">/* select第一个参数需要 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">                maxi = i;                                       <span class="comment">/* 保证maxi存的总是client[]最后一个元素下标 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;                               <span class="comment">/* 检测哪个clients 有数据就绪 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((n = Read(sockfd, buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">0</span>) &#123;    <span class="comment">/* 当client关闭链接时,服务器端也关闭对应链接 */</span></span><br><span class="line">                    Close(sockfd);</span><br><span class="line">                    FD_CLR(sockfd, &amp;allset);                        <span class="comment">/* 解除select对此文件描述符的监控 */</span></span><br><span class="line">                    client[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">                    Write(sockfd, buf, n);</span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--nready == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;                                          <span class="comment">/* 跳出for, 但还在while中 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="select优缺点："><a href="#select优缺点：" class="headerlink" title="select优缺点："></a>select优缺点：</h4><pre><code>缺点：	监听上限受文件描述符限制。 最大 1024.

    检测满足条件的fd， 自己添加业务逻辑提高小。 提高了编码难度。

优点：	跨平台。win、linux、macOS、Unix、类Unix、mips
</code></pre>
<h2 id="day3笔记"><a href="#day3笔记" class="headerlink" title="day3笔记"></a>day3笔记</h2><p>TCP状态时序图：</p>
<pre><code>结合三次握手、四次挥手 理解记忆。


1. 主动发起连接请求端：	CLOSE -- 发送SYN -- SEND_SYN -- 接收 ACK、SYN -- SEND_SYN -- 发送 ACK -- ESTABLISHED（数据通信态）

2. 主动关闭连接请求端： ESTABLISHED（数据通信态） -- 发送 FIN -- FIN_WAIT_1 -- 接收ACK -- FIN_WAIT_2（半关闭）

            -- 接收对端发送 FIN -- FIN_WAIT_2（半关闭）-- 回发ACK -- TIME_WAIT（只有主动关闭连接方，会经历该状态）

            -- 等 2MSL时长 -- CLOSE 

3. 被动接收连接请求端： CLOSE -- LISTEN -- 接收 SYN -- LISTEN -- 发送 ACK、SYN -- SYN_RCVD -- 接收ACK -- ESTABLISHED（数据通信态）

4. 被动关闭连接请求端： ESTABLISHED（数据通信态） -- 接收 FIN -- ESTABLISHED（数据通信态） -- 发送ACK 

            -- CLOSE_WAIT (说明对端【主动关闭连接端】处于半关闭状态) -- 发送FIN -- LAST_ACK -- 接收ACK -- CLOSE


重点记忆： ESTABLISHED、FIN_WAIT_2 &lt;--&gt; CLOSE_WAIT、TIME_WAIT（2MSL）

netstat -apn | grep  端口号
</code></pre>
<p>2MSL时长：</p>
<pre><code>一定出现在【主动关闭连接请求端】。 --- 对应 TIME_WAIT 状态。

保证，最后一个 ACK 能成功被对端接收。（等待期间，对端没收到我发的ACK，对端会再次发送FIN请求。）
</code></pre>
<p>端口复用:</p>
<pre><code>int opt = 1;		// 设置端口复用。

setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt));
</code></pre>
<p>半关闭：</p>
<pre><code>通信双方中，只有一端关闭通信。  --- FIN_WAIT_2

close（cfd）;

shutdown(int fd, int how);	

    how: 	SHUT_RD	关读端

        SHUT_WR	关写端

        SHUT_RDWR 关读写

shutdown在关闭多个文件描述符应用的文件时，采用全关闭方法。close，只关闭一个。
</code></pre>
<p>​	<br>select多路IO转接：</p>
<pre><code>原理：  借助内核， select 来监听， 客户端连接、数据通信事件。

void FD_ZERO(fd_set *set);	--- 清空一个文件描述符集合。

    fd_set rset;

    FD_ZERO(&amp;rset);

void FD_SET(int fd, fd_set *set);	--- 将待监听的文件描述符，添加到监听集合中

    FD_SET(3, &amp;rset);	FD_SET(5, &amp;rset);	FD_SET(6, &amp;rset);


void FD_CLR(int fd, fd_set *set);	--- 将一个文件描述符从监听集合中 移除。

    FD_CLR（4， &amp;rset）;

int  FD_ISSET(int fd, fd_set *set);	--- 判断一个文件描述符是否在监听集合中。

    返回值： 在：1；不在：0；

    FD_ISSET（4， &amp;rset）;
    
int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);

    nfds：监听的所有文件描述符中，最大文件描述符+1

    readfds： 读 文件描述符监听集合。	传入、传出参数

    writefds：写 文件描述符监听集合。	传入、传出参数		NULL

    exceptfds：异常 文件描述符监听集合	传入、传出参数		NULL

    timeout： 	&gt; 0: 	设置监听超时时长。

            NULL:	阻塞监听

            0：	非阻塞监听，轮询
    返回值：

        &gt; 0:	所有监听集合（3个）中， 满足对应事件的总数。

        0：	没有满足监听条件的文件描述符

        -1： 	errno
</code></pre>
<p>思路分析：</p>
<pre><code>int maxfd = 0；

lfd = socket() ;			创建套接字

maxfd = lfd；

bind();					绑定地址结构

listen();				设置监听上限

fd_set rset， allset;			创建r监听集合

FD_ZERO(&amp;allset);				将r监听集合清空

FD_SET(lfd, &amp;allset);			将 lfd 添加至读集合中。

while（1） &#123;

    rset = allset；			保存监听集合

    ret  = select(lfd+1， &amp;rset， NULL， NULL， NULL);		监听文件描述符集合对应事件。

    if（ret &gt; 0） &#123;							有监听的描述符满足对应事件
    
        if (FD_ISSET(lfd, &amp;rset)) &#123;				// 1 在。 0不在。

            cfd = accept（）；				建立连接，返回用于通信的文件描述符

            maxfd = cfd；

            FD_SET(cfd, &amp;allset);				添加到监听通信描述符集合中。
        &#125;

        for （i = lfd+1； i &lt;= 最大文件描述符; i++）&#123;

            FD_ISSET(i, &amp;rset)				有read、write事件

            read（）

            小 -- 大

            write();
        &#125;	
    &#125;
&#125;
</code></pre>
<p>select优缺点：</p>
<pre><code>缺点：	监听上限受文件描述符限制。 最大 1024.

    检测满足条件的fd， 自己添加业务逻辑提高小。 提高了编码难度。

优点：	跨平台。win、linux、macOS、Unix、类Unix、mips
</code></pre>
<h3 id="poll函数实现响应式服务器（了解）"><a href="#poll函数实现响应式服务器（了解）" class="headerlink" title="poll函数实现响应式服务器（了解）"></a>poll函数实现响应式服务器（了解）</h3><h4 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h4><p>poll是对select的改进，但是它是个半成品，相对select提升不大。最终版本是epoll，所以poll了解一下就完事儿，重点掌握epoll。</p>
<p> <code>int poll(struct pollfd *fds, nfds_t nfds, int timeout); </code></p>
<blockquote>
<p>fds：监听的文件描述符【数组】 </p>
<p>​           struct pollfd {              </p>
<p>​              int fd：   待监听的文件描述符              </p>
<p>​              short_events：    待监听的文件描述符对应的监听事件 </p>
<p>​                     取值：POLLIN、POLLOUT、POLLERR </p>
<p>​              short revnets：   传入时， 给0。如果满足对应事件的话， 返回 非0 –&gt; POLLIN、POLLOUT、POLLERR</p>
<p>​           } </p>
<p>​			struct pollfd *fds 中的fds是个数组，调用也是fds[0].fd，fds[0].short_events调用</p>
<p>​       nfds: 监听数组的，实际有效监听个数。 </p>
<p>​       timeout:  &gt; 0:  超时时长。单位：毫秒。 </p>
<p>​             -1:  阻塞等待 </p>
<p>​             0：  不阻塞 </p>
<p>​       返回值：返回满足对应监听事件的文件描述符 总个数。 </p>
</blockquote>
<p>​    优点：</p>
<p>​       自带数组结构。 可以将 监听事件集合 和 返回事件集合 分离。</p>
<p>​       拓展 监听上限。 超出 1024限制。 </p>
<p>​    缺点：</p>
<p>​       不能跨平台。 Linux </p>
<p>​       无法直接定位满足监听事件的文件描述符， 编码难度较大。</p>
<h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>![1708588840601](D:\Program Files (x86)\MyBlog\source_posts\网络编程\图片1.png)</p>
<h4 id="poll实现代码"><a href="#poll实现代码" class="headerlink" title="poll实现代码"></a>poll实现代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 1024  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i, j, maxi, listenfd, connfd, sockfd;  </span><br><span class="line">    <span class="type">int</span> nready;  </span><br><span class="line">    <span class="type">ssize_t</span> n;  </span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];  </span><br><span class="line">    <span class="type">socklen_t</span> clilen;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span>  </span><br><span class="line">  </span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    Bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">  </span><br><span class="line">    Listen(listenfd, <span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;  </span><br><span class="line">    client[<span class="number">0</span>].events = POLLRDNORM;                  <span class="comment">/* listenfd监听普通读事件 */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)  </span><br><span class="line">        client[i].fd = <span class="number">-1</span>;                          <span class="comment">/* 用-1初始化client[]里剩下元素 */</span>  </span><br><span class="line">    maxi = <span class="number">0</span>;                                       <span class="comment">/* client[]数组有效元素中最大元素下标 */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;  </span><br><span class="line">        nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);          <span class="comment">/* 阻塞 */</span>  </span><br><span class="line">        <span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;       <span class="comment">/* 有客户端链接请求 */</span>  </span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);  </span><br><span class="line">            connfd = Accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;clilen);  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,  </span><br><span class="line">                    inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),  </span><br><span class="line">                    ntohs(cliaddr.sin_port));  </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    client[i].fd = connfd;  <span class="comment">/* 找到client[]中空闲的位置，存放accept返回的connfd */</span>  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX)  </span><br><span class="line">                perr_exit(<span class="string">&quot;too many clients&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            client[i].events = POLLRDNORM;      <span class="comment">/* 设置刚刚返回的connfd，监控读事件 */</span>  </span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxi)  </span><br><span class="line">                maxi = i;                       <span class="comment">/* 更新client[]中最大元素下标 */</span>  </span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">continue</span>;                       <span class="comment">/* 没有更多就绪事件时,继续回到poll阻塞 */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123;            <span class="comment">/* 检测client[] */</span>  </span><br><span class="line">            <span class="keyword">if</span> ((sockfd = client[i].fd) &lt; <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;  </span><br><span class="line">                <span class="keyword">if</span> ((n = Read(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123; <span class="comment">/* 当收到 RST标志时 */</span>  </span><br><span class="line">                        <span class="comment">/* connection reset by client */</span>  </span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client[%d] aborted connection\n&quot;</span>, i);  </span><br><span class="line">                        Close(sockfd);  </span><br><span class="line">                        client[i].fd = <span class="number">-1</span>;  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        perr_exit(<span class="string">&quot;read error&quot;</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="comment">/* connection closed by client */</span>  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>, i);  </span><br><span class="line">                    Close(sockfd);  </span><br><span class="line">                    client[i].fd = <span class="number">-1</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)  </span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);  </span><br><span class="line">                        Writen(sockfd, buf, n);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)  </span><br><span class="line">                    <span class="keyword">break</span>;              <span class="comment">/* no more readable descriptors */</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="poll优缺点："><a href="#poll优缺点：" class="headerlink" title="poll优缺点："></a>poll优缺点：</h4><blockquote>
<p>优点：</p>
<p>​		自带数组结构。 可以将 监听事件集合 和 返回事件集合 分离。</p>
<p>​       拓展 监听上限。 超出 1024限制。 </p>
<p>​	修改：<br>​		打开 sudo vi &#x2F;etc&#x2F;security&#x2F;limits.conf， 写入：</p>
<pre><code>    * soft nofile 65536			--&gt; 设置默认值， 可以直接借助命令修改。 【注销用户，使其生效】
    * hard nofile 100000			--&gt; 命令修改上限。
</code></pre>
<p>缺点：</p>
<p>​       不能跨平台。 Linux </p>
<p>​       无法直接定位满足监听事件的文件描述符， 编码难度较大。(和select相同)</p>
</blockquote>
<h5 id="突破-1024-文件描述符限制："><a href="#突破-1024-文件描述符限制：" class="headerlink" title="突破 1024 文件描述符限制："></a>突破 1024 文件描述符限制：</h5><p>​	先查看：<br>​	cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max  –&gt; 当前计算机所能打开的最大文件个数。 受硬件影响。<br>​	ulimit -a 	——&gt; 当前用户下的进程，默认打开文件描述符个数。  缺省为 1024<br>​	![1708604512946](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708604512946.png)       </p>
<p>修改：<br>        打开 sudo vi &#x2F;etc&#x2F;security&#x2F;limits.conf， 写入：</p>
<pre><code>    * soft nofile 65536			--&gt; 设置默认值， 可以直接借助命令修改。 【注销用户，使其生效，往下调（1000-&gt;500）可以直接生效，往上调（1000-&gt;2000)需要注销用户，可以直接借用命令修改（open files后面有个(-n)：ulimit -n 21000】

    * hard nofile 100000			--&gt; 命令修改上限。来限制上面修改的最大值
</code></pre>
<p>![1708605538370](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708605538370.png)</p>
<h3 id="epoll函数实现响应式服务器（重要）"><a href="#epoll函数实现响应式服务器（重要）" class="headerlink" title="epoll函数实现响应式服务器（重要）"></a>epoll函数实现响应式服务器（重要）</h3><p>使用有大量连接但是只有少量活跃的情况</p>
<h4 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h4><p>（平衡二叉树里面的特例：红黑树）</p>
<pre><code>1、创建一棵监听红黑树
int epoll_create(int size);						
    size：创建的红黑树的监听节点数量。（仅供内核参考。）
    返回值：指向新创建的红黑树的根节点的 fd。 
        失败： -1 errno
        
2、操作监听红黑树
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);	
    epfd：epoll_create 函数的返回值。 epfd
    op：对该监听红黑数所做的操作。
        EPOLL_CTL_ADD 添加fd到 监听红黑树
        EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。
        EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）
    fd(fd111)：
        待监听的fd		
    event：	本质 struct epoll_event 结构体 的地址，这个参数是一个传出参数,是要把这个结构体放到树上去，将来如果对应的事件满足的话，其中的fd就会被设置的后面的epoll_wait()函数里面
        成员 events：
            EPOLLIN / EPOLLOUT / EPOLLERR
        成员 data： 联合体（共用体）：
            int fd;	  对应监听事件的 fd    对应前面的待监听的fd(fd111)
            void *ptr； 后面再讲  libevent通过把它打造成回调函数的模式（epoll反应堆模型），它和fd是共用体，和fd共享同一块地址空间
            uint32_t u32;  这个不用
            uint64_t u64;  这个不用 		
    返回值：成功 0； 失败： -1 errno
    int poll(struct pollfd *fds, nfds_t nfds, int timeout);
   	struct pollfd *fds 中的fds是个数组，调用也是fds[0].fd，fds[0].short_events调用，这个0也是一个结构体 的地址，这个fds作为数组就是这些地址的集合
   	数组是一连串连续的地址，数组名是首地址，指针指向下一个地址


3、阻塞监听。
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 	
    epfd：epoll_create 函数的返回值。 epfd
    events：传出参数，【数组】， 满足监听条件的 那些 fd 结构体。，第二个函数中的event是一个结构体，而这个events是一个数组，用来存内核得到事件的集合
    maxevents：数组 元素的总个数。 1024			
        struct epoll_event evnets[1024]
    timeout：
        -1: 阻塞
        0： 不阻塞
        &gt;0: 超时时间 （毫秒）
    返回值：
        &gt; 0: 满足监听的 总个数。 可以用作循环上限。

        0： 没有fd满足监听事件

        -1：失败。 errno
</code></pre>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>基本就是为kfd(cfd)创建一个结构体，然后挂到红黑树上，再在while(1)里面执行监听操作，如果有事件发生，再执行accept挂到红黑树(lfd)或者进行读写操作(cfd)</p>
<pre><code>lfd = socket（）;			监听连接事件lfd
bind();
listen();

int epfd = epoll_create(1024);				epfd, 监听红黑树的树根。

struct epoll_event tep, ep[1024];			tep, 临时变量，反复使用，用来设置单个fd属性， ep 是 epoll_wait() 传出的满足监听事件的数组。

tep.events = EPOLLIN;					初始化  lfd的监听属性。
tep.data.fd = lfd

epoll_ctl(epfd， EPOLL_CTL_ADD, lfd, &amp;tep);		将 lfd 添加到监听红黑树上。

while (1) &#123;
ret = epoll_wait(epfd， ep，1024， -1);			实施监听

for (i = 0; i &lt; ret; i++) &#123;
    
    if (ep[i].data.fd == lfd) &#123;				// lfd 满足读事件，有新的客户端发起连接请求

        cfd = Accept();

        tep.events = EPOLLIN;				初始化  cfd的监听属性。
        tep.data.fd = cfd;

        epoll_ctl(epfd， EPOLL_CTL_ADD, cfd, &amp;tep);

    &#125; else &#123;						cfd 们 满足读事件， 有客户端写数据来。

        n = read(ep[i].data.fd, buf, sizeof(buf));

        if ( n == 0) &#123;

            close(ep[i].data.fd);

            epoll_ctl(epfd， EPOLL_CTL_DEL, ep[i].data.fd , NULL);	// 将关闭的cfd，从监听树上摘下。

        &#125; else if （n &gt; 0） &#123;

            小--大
            write(ep[i].data.fd, buf, n);
        &#125;
    &#125;
&#125;
&#125;
</code></pre>
<h4 id="epoll实现代码"><a href="#epoll实现代码" class="headerlink" title="epoll实现代码"></a>epoll实现代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 10  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> efd, i;  </span><br><span class="line">    <span class="type">int</span> pfd[<span class="number">2</span>];  </span><br><span class="line">    <span class="type">pid_t</span> pid;  </span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], ch = <span class="string">&#x27;a&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line">    pipe(pfd);  </span><br><span class="line">    pid = fork();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;             <span class="comment">//子 写  </span></span><br><span class="line">        close(pfd[<span class="number">0</span>]);  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="comment">//aaaa\n  </span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXLINE/<span class="number">2</span>; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">            ch++;  </span><br><span class="line">            <span class="comment">//bbbb\n  </span></span><br><span class="line">            <span class="keyword">for</span> (; i &lt; MAXLINE; i++)  </span><br><span class="line">                buf[i] = ch;  </span><br><span class="line">            buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">            ch++;  </span><br><span class="line">            <span class="comment">//aaaa\nbbbb\n  </span></span><br><span class="line">            write(pfd[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));  </span><br><span class="line">            sleep(<span class="number">5</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        close(pfd[<span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;       <span class="comment">//父 读  </span></span><br><span class="line">        <span class="keyword">struct</span> epoll_event event;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span>        <span class="comment">//epoll_wait就绪返回event  </span></span><br><span class="line">        <span class="type">int</span> res, len;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[<span class="number">1</span>]);  </span><br><span class="line">        efd = epoll_create(<span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        event.events = EPOLLIN | EPOLLET;     <span class="comment">// ET 边沿触发  </span></span><br><span class="line">       <span class="comment">// event.events = EPOLLIN;                 // LT 水平触发 (默认)  </span></span><br><span class="line">        event.data.fd = pfd[<span class="number">0</span>];  </span><br><span class="line">        epoll_ctl(efd, EPOLL_CTL_ADD, pfd[<span class="number">0</span>], &amp;event);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">            res = epoll_wait(efd, resevent, <span class="number">10</span>, <span class="number">-1</span>);  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;res %d\n&quot;</span>, res);  </span><br><span class="line">            <span class="keyword">if</span> (resevent[<span class="number">0</span>].data.fd == pfd[<span class="number">0</span>]) &#123;  </span><br><span class="line">                len = read(pfd[<span class="number">0</span>], buf, MAXLINE/<span class="number">2</span>);  </span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        close(pfd[<span class="number">0</span>]);  </span><br><span class="line">        close(efd);  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="epoll的触发模式："><a href="#epoll的触发模式：" class="headerlink" title="epoll的触发模式："></a>epoll的触发模式：</h4><pre><code>ET(edge-triggered)模式：

    边沿触发：

        缓冲区剩余未读尽的数据不会导致 epoll_wait 返回。 新的事件满足，才会触发。

        struct epoll_event event;

        event.events = EPOLLIN | EPOLLET;
LT(level triggered)模式：

    水平触发 -- 默认采用模式。

        缓冲区剩余未读尽的数据会导致 epoll_wait 返回。
</code></pre>
<p>两者的区别在于：</p>
<p>如果创建文件描述符，先写入”aaaa\n”，又写入”bbbb\n”，让这个文件描述符上树，在另一变只读取了”aaaa\n”，还剩下”bbbb\n”，如果是LT可以读，但是ET读不了，只有再往后写ET也读不了，只有再往后写”cccc\n”才能读”bbbb\n”</p>
<p>如果对方发来的1000个字节，我只需要读前500个字节剩下的想丢弃，那么我用ET模式，但是要ET就必须用非阻塞模式</p>
<p>server边沿触发，编译运行，结果如下：</p>
<p>​       ![1708588840601](D:\Program Files (x86)\MyBlog\source_posts\网络编程\图片2.png)                                        </p>
<p>​    运行后，每过5秒钟服务器才输出一组字符，这是就是边沿触发的效果。</p>
<p>更改服务器为水平触发模式，运行程序，如下：</p>
<p>​    ![1708588840601](D:\Program Files (x86)\MyBlog\source_posts\网络编程\图片3.png)</p>
<p>运行后，每5秒输出两组字符串，这是因为只写入了两组，这个模式的服务器，缓冲区有多少读多少。</p>
<pre><code>结论：
    epoll 的 ET模式， 高效模式，但是只支持 非阻塞模式。 --- 忙轮询。

    struct epoll_event event;

    event.events = EPOLLIN | EPOLLET;   //设置方式：原来是event.events = EPOLLIN 改成这个

    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd， &amp;event);	

    int flg = fcntl(cfd, F_GETFL);	

    flg |= O_NONBLOCK;

    fcntl(cfd, F_SETFL, flg);

优点：

    高效。突破1024文件描述符。

缺点：
    不能跨平台。 Linux。
</code></pre>
<p>文件描述符：</p>
<p>文件描述符可以来源于管道运算符pipe（进程间通信），也可以来源于套接字socket（网络通信）</p>
<h4 id="readn阻塞："><a href="#readn阻塞：" class="headerlink" title="readn阻塞："></a>readn阻塞：</h4><p>​		readn调用的阻塞，比如设定读500个字符，但是因为只发送了498，就只读到498个字符，完事儿阻塞了，等另剩下的2个字符，然而在server代码里，一旦read变为readn阻塞了，它就不会被唤醒了，因为epoll_wait因为readn的阻塞不会循环执行，读不到新数据。有点死锁的意思，差俩字符所以阻塞，因为阻塞，读不到新字符。</p>
<p>LT(level triggered)：LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select&#x2F;poll都是这种模型的代表。</p>
<p>ET(edge-triggered)：ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once).</p>
<h5 id="如果要在ET的情况下用fcntl函数实现非阻塞："><a href="#如果要在ET的情况下用fcntl函数实现非阻塞：" class="headerlink" title="如果要在ET的情况下用fcntl函数实现非阻塞："></a>如果要在ET的情况下用fcntl函数实现非阻塞：</h5><p>![1708659878332](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708659878332.png)</p>
<p>三个参数分别是文件描述符、要干的事情和变参，两个作用，一是设置阻塞非阻塞，二是dup2(cfd,cfd1)函数复制文件描述符那里用过</p>
<h6 id="设置阻塞非阻塞："><a href="#设置阻塞非阻塞：" class="headerlink" title="设置阻塞非阻塞："></a>设置阻塞非阻塞：</h6><p>先<code>F_GETFL()</code>把flag的值作为参数返回出来，这个flag的值本质上是一个位图，他有一个位表示阻塞还是非阻塞，默认是零的话给他位或变为1.</p>
<p>设置非阻塞模式之后，没有读到字节就直接返回了，但是可能读到498字节，剩下的两个字节是还没有发过来，如果想要再读剩下的两个字节，那么需要忙轮询</p>
<p>在设置边沿触发之后，用accept得到cfd，设置cfd非阻塞，添加下面三句代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN | EPOLLET;   <span class="comment">//设置方式：原来是event.events = EPOLLIN 改成这个</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//event.events = EPOLLIN;  </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);  </span><br><span class="line"> cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);  </span><br><span class="line"> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;cliaddr_len);  </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,  </span><br><span class="line">       inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),  </span><br><span class="line">       ntohs(cliaddr.sin_port));  </span><br><span class="line"></span><br><span class="line">flag = fcntl(connfd, F_GETFL);          <span class="comment">/* 修改connfd为非阻塞读 */</span>  </span><br><span class="line">flag |= O_NONBLOCK;  </span><br><span class="line">fcntl(connfd, F_SETFL, flag);  </span><br><span class="line"></span><br><span class="line">event.data.fd = connfd;  </span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);      <span class="comment">//将connfd加入监听红黑树  </span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait begin\n&quot;</span>);  </span><br><span class="line">        res = epoll_wait(efd, res_event, <span class="number">10</span>, <span class="number">-1</span>);        <span class="comment">//最多10个, 阻塞监听  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait end res %d\n&quot;</span>, res);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (res_event[<span class="number">0</span>].data.fd == connfd) &#123;  </span><br><span class="line">            <span class="keyword">while</span> ((len = read(connfd, buf, MAXLINE/<span class="number">2</span>)) &gt;<span class="number">0</span> )    <span class="comment">//非阻塞读, 轮询  </span></span><br><span class="line">                write(STDOUT_FILENO, buf, len);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样可以设置那个套接字为非阻塞状态，只要readn读完就返回而不是阻塞在那里，没有发送数据的话后面的epoll_wait该等还是等着</p>
<pre><code>    epoll 的 ET模式， 高效模式，但是只支持 非阻塞模式。 --- 忙轮询。

    struct epoll_event event;
    event.events = EPOLLIN | EPOLLET;
    
    int flg = fcntl(cfd, F_GETFL);	
    flg |= O_NONBLOCK;
    fcntl(cfd, F_SETFL, flg);
    
    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd， &amp;event);	
</code></pre>
<h4 id="epoll优缺点："><a href="#epoll优缺点：" class="headerlink" title="epoll优缺点："></a>epoll优缺点：</h4><pre><code>优点：
    高效。突破1024文件描述符。

缺点：
    不能跨平台。 Linux。
</code></pre>
<h4 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h4><p>epoll ET模式 + 非阻塞、轮询 + void *ptr。</p>
<p>不看了79-84集<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iJ411S7UA?p=85&vd_source=4e66034f3b307a25122b6a56d66b54c8">https://www.bilibili.com/video/BV1iJ411S7UA?p=85&amp;vd_source=4e66034f3b307a25122b6a56d66b54c8</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);	</span><br><span class="line">	epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line">	op：对该监听红黑数所做的操作。</span><br><span class="line">		EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line">		EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。</span><br><span class="line">		EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）</span><br><span class="line">	fd(fd111)：</span><br><span class="line">		待监听的fd		</span><br><span class="line">	event：	本质 struct epoll_event 结构体 的地址，这个参数是一个传出参数,是要把这个结构体放到树上去，将来如果对应的事件满足的话，其中的fd就会被设置的后面的epoll_wait()函数里面</span><br><span class="line">		成员 events：</span><br><span class="line">			EPOLLIN / EPOLLOUT / EPOLLERR</span><br><span class="line">		成员 data： 联合体（共用体）：</span><br><span class="line">			int fd;	  对应监听事件的 fd    对应前面的待监听的fd(fd111)</span><br><span class="line">			void *ptr； 后面再讲  libevent通过把它打造成回调函数的模式（epoll反应堆模型），它和fd是共用体，和fd共享同一块地址空间</span><br><span class="line">			uint32_t u32;  这个不用</span><br><span class="line">			uint64_t u64;  这个不用 		</span><br><span class="line">	返回值：成功 0； 失败： -1 errno</span><br><span class="line">如果我们定义一个结构体来封装fd</span><br><span class="line">struct evt &#123;</span><br><span class="line">	int fd</span><br><span class="line">	void (*func)(int fd)</span><br><span class="line">&#125;*ptr</span><br><span class="line">就可以自动调用（回调）</span><br></pre></td></tr></table></figure>

<p>原来</p>
<pre><code>socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--

    -- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 

    -- read() --- 小-&gt;大 -- write回去。
</code></pre>
<p>​	<br>反应堆：不但要监听 cfd 的读事件、还要监听cfd的写事件。</p>
<p>反应堆的理解：加入IO转接之后，有了事件，server才去处理，这里反应堆也是这样，由于网络环境复杂，服务器处理数据之后，可能并不能直接写回去，比如遇到网络繁忙或者对方缓冲区已经满了这种情况，就不能直接写回给客户端。反应堆就是在处理数据之后，监听写事件，能写会客户端了，才去做写回操作。写回之后，再改为监听读事件。如此循环。</p>
<pre><code>socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--

-- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 

-- read() --- 小-&gt;大 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听写事件

-- 等待 epoll_wait 返回 -- 说明 cfd 可写 -- write回去 -- cfd从监听红黑树上摘下 -- EPOLLIN 

-- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听读事件 -- epoll_wait 监听
</code></pre>
<h2 id="day4笔记"><a href="#day4笔记" class="headerlink" title="day4笔记"></a>day4笔记</h2><p>多路IO转接：</p>
<p>select：</p>
<p>poll：<br>    int poll(struct pollfd *fds, nfds_t nfds, int timeout);</p>
<pre><code>    fds：监听的文件描述符【数组】

        struct pollfd &#123;
            
            int fd：	待监听的文件描述符
            
            short events：	待监听的文件描述符对应的监听事件

                    取值：POLLIN、POLLOUT、POLLERR

            short revnets：	传入时， 给0。如果满足对应事件的话， 返回 非0 --&gt; POLLIN、POLLOUT、POLLERR
        &#125;

    nfds: 监听数组的，实际有效监听个数。

    timeout:  &gt; 0:  超时时长。单位：毫秒。

          -1:	阻塞等待

          0：  不阻塞

    返回值：返回满足对应监听事件的文件描述符 总个数。

优点：
    自带数组结构。 可以将 监听事件集合 和 返回事件集合 分离。

    拓展 监听上限。 超出 1024限制。

缺点：
    不能跨平台。 Linux

    无法直接定位满足监听事件的文件描述符， 编码难度较大。
</code></pre>
<p>read 函数返回值：</p>
<pre><code>&gt; 0: 实际读到的字节数

=0： socket中，表示对端关闭。close（）

-1：	如果 errno == EINTR   被异常终端。 需要重启。

    如果 errno == EAGIN 或 EWOULDBLOCK 以非阻塞方式读数据，但是没有数据。  需要，再次读。

    如果 errno == ECONNRESET  说明连接被 重置。 需要 close（），移除监听队列。

    错误。 
</code></pre>
<p>突破 1024 文件描述符限制：</p>
<pre><code>cat /proc/sys/fs/file-max  --&gt; 当前计算机所能打开的最大文件个数。 受硬件影响。

ulimit -a 	——&gt; 当前用户下的进程，默认打开文件描述符个数。  缺省为 1024

修改：
    打开 sudo vi /etc/security/limits.conf， 写入：

    * soft nofile 65536			--&gt; 设置默认值， 可以直接借助命令修改。 【注销用户，使其生效】

    * hard nofile 100000			--&gt; 命令修改上限。
</code></pre>
<p>epoll：<br>    int epoll_create(int size);						创建一棵监听红黑树</p>
<pre><code>    size：创建的红黑树的监听节点数量。（仅供内核参考。）

    返回值：指向新创建的红黑树的根节点的 fd。 

        失败： -1 errno

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);	操作监听红黑树

    epfd：epoll_create 函数的返回值。 epfd

    op：对该监听红黑数所做的操作。

        EPOLL_CTL_ADD 添加fd到 监听红黑树

        EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。

        EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）

    fd：
        待监听的fd

    event：	本质 struct epoll_event 结构体 地址

        成员 events：

            EPOLLIN / EPOLLOUT / EPOLLERR

        成员 data： 联合体（共用体）：

            int fd;	  对应监听事件的 fd

            void *ptr； 

            uint32_t u32;

            uint64_t u64;		

    返回值：成功 0； 失败： -1 errno


int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 	 阻塞监听。

    epfd：epoll_create 函数的返回值。 epfd

    events：传出参数，【数组】， 满足监听条件的 哪些 fd 结构体。

    maxevents：数组 元素的总个数。 1024
            
        struct epoll_event evnets[1024]
    timeout：

        -1: 阻塞

        0： 不阻塞

        &gt;0: 超时时间 （毫秒）

    返回值：

        &gt; 0: 满足监听的 总个数。 可以用作循环上限。

        0： 没有fd满足监听事件

        -1：失败。 errno
</code></pre>
<p>epoll实现多路IO转接思路：</p>
<p>lfd &#x3D; socket（）;			监听连接事件lfd<br>bind();<br>listen();</p>
<p>int epfd &#x3D; epoll_create(1024);				epfd, 监听红黑树的树根。</p>
<p>struct epoll_event tep, ep[1024];			tep, 用来设置单个fd属性， ep 是 epoll_wait() 传出的满足监听事件的数组。</p>
<p>tep.events &#x3D; EPOLLIN;					初始化  lfd的监听属性。<br>tep.data.fd &#x3D; lfd</p>
<p>epoll_ctl(epfd， EPOLL_CTL_ADD, lfd, &amp;tep);		将 lfd 添加到监听红黑树上。</p>
<p>while (1) {</p>
<pre><code>ret = epoll_wait(epfd， ep，1024， -1);			实施监听

for (i = 0; i &lt; ret; i++) &#123;
    
    if (ep[i].data.fd == lfd) &#123;				// lfd 满足读事件，有新的客户端发起连接请求

        cfd = Accept();

        tep.events = EPOLLIN;				初始化  cfd的监听属性。
        tep.data.fd = cfd;

        epoll_ctl(epfd， EPOLL_CTL_ADD, cfd, &amp;tep);

    &#125; else &#123;						cfd 们 满足读事件， 有客户端写数据来。

        n = read(ep[i].data.fd, buf, sizeof(buf));

        if ( n == 0) &#123;

            close(ep[i].data.fd);

            epoll_ctl(epfd， EPOLL_CTL_DEL, ep[i].data.fd , NULL);	// 将关闭的cfd，从监听树上摘下。

        &#125; else if （n &gt; 0） &#123;

            小--大
            write(ep[i].data.fd, buf, n);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>epoll 事件模型：</p>
<pre><code>ET模式：

    边沿触发：

        缓冲区剩余未读尽的数据不会导致 epoll_wait 返回。 新的事件满足，才会触发。

        struct epoll_event event;

        event.events = EPOLLIN | EPOLLET;
LT模式：

    水平触发 -- 默认采用模式。

        缓冲区剩余未读尽的数据会导致 epoll_wait 返回。
</code></pre>
<p>​	<br>​	结论：<br>​		epoll 的 ET模式， 高效模式，但是只支持 非阻塞模式。 — 忙轮询。<br>​	<br>​		struct epoll_event event;<br>​	<br>        event.events &#x3D; EPOLLIN | EPOLLET;</p>
<pre><code>    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd， &amp;event);	

    int flg = fcntl(cfd, F_GETFL);	

    flg |= O_NONBLOCK;

    fcntl(cfd, F_SETFL, flg);

优点：

    高效。突破1024文件描述符。

缺点：
    不能跨平台。 Linux。
</code></pre>
<p>epoll 反应堆模型：</p>
<pre><code>epoll ET模式 + 非阻塞、轮询 + void *ptr。

原来：	socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--

    -- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 

    -- read() --- 小-&gt;大 -- write回去。

反应堆：不但要监听 cfd 的读事件、还要监听cfd的写事件。

    socket、bind、listen -- epoll_create 创建监听 红黑树 --  返回 epfd -- epoll_ctl() 向树上添加一个监听fd -- while（1）--

    -- epoll_wait 监听 -- 对应监听fd有事件产生 -- 返回 监听满足数组。 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd 满足 

    -- read() --- 小-&gt;大 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听写事件

    -- 等待 epoll_wait 返回 -- 说明 cfd 可写 -- write回去 -- cfd从监听红黑树上摘下 -- EPOLLIN 

    -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑上监听读事件 -- epoll_wait 监听

eventset函数：

    设置回调函数。   lfd --》 acceptconn()

            cfd --&gt; recvdata();

            cfd --&gt; senddata();
eventadd函数：

    将一个fd， 添加到 监听红黑树。  设置监听 read事件，还是监听写事件。


网络编程中：  	read --- recv()

        write --- send();
</code></pre>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>![1708830507101](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708830507101.png)</p>
<p>如果服务器起一个线程去消化客户端产生的线程，这样就可以把服务器解放出来</p>
<p>但是多线程多进程比多路IO转接效率低</p>
<p>同时在一个进程中维护n给线程进程，在通信的时候cpu要在多个线程之间切换，系统资源消耗比较大</p>
<p>换成多路IO转接只需要一个进程线程就可以了，系统资源占用比较小，内核会自动帮你维护</p>
<p>也就是说每次创建线程销毁线程是开销大的一个原因，如果每次创建一堆线程（线程池），就可以减少开销</p>
<p>![1708831987508](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708831987508.png)</p>
<h3 id="线程池的步骤"><a href="#线程池的步骤" class="headerlink" title="线程池的步骤"></a>线程池的步骤</h3><p>​		首先创建一些线程池，里面有一些初始化的最小线程数、指定最大线程数，所有的线程都通过条件变量（任务队列是否为空）阻塞在任务队列上面，等任务满足了就自动调用回调函数去处理，任务多了就给线程池扩容，任务少了就给线程池瘦身，管理扩容和瘦身是用管理线程做的，管理线程借助忙线程数、活着的线程数和任务队列中的实际任务数之间按照某个算法算一个比例出来，达到某一个比例的时候，我们就要扩容或者瘦身。销毁线程是在任务队列里面发一个假消息去给阻塞在任务队列为空但是线程不为空的线程，让它以为任务来了，然后把要删除的线程数置成非零值，这样线程就会被wait唤醒，然后进入if语句判断销毁线程数不是0就会进入if语句里面，然后pthread就自动退出了。</p>
<h3 id="线程池相关函数"><a href="#线程池相关函数" class="headerlink" title="线程池相关函数"></a>线程池相关函数</h3><p>struct threadpool_t {</p>
<pre><code>pthread_mutex_t lock;               /* 用于锁住本结构体 */    
pthread_mutex_t thread_counter;     /* 记录忙状态线程个数de琐 -- busy_thr_num */

pthread_cond_t queue_not_full;      /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */
pthread_cond_t queue_not_empty;     /* 任务队列里不为空时，通知等待任务的线程 */

pthread_t *threads;                 /* 存放线程池中每个线程的tid。数组 */
pthread_t adjust_tid;               /* 存管理线程tid */
threadpool_task_t *task_queue;      /* 任务队列(数组首地址) */

int min_thr_num;                    /* 线程池最小线程数 */
int max_thr_num;                    /* 线程池最大线程数 */
int live_thr_num;                   /* 当前存活线程个数 */
int busy_thr_num;                   /* 忙状态线程个数 */
int wait_exit_thr_num;              /* 要销毁的线程个数 */

int queue_front;                    /* task_queue队头下标 */
int queue_rear;                     /* task_queue队尾下标 */
int queue_size;                     /* task_queue队中实际任务数 */
int queue_max_size;                 /* task_queue队列可容纳任务数上限 */

int shutdown;                       /* 标志位，线程池使用状态，true或false */
</code></pre>
<p>};</p>
<p>typedef struct {</p>
<pre><code>void *(*function)(void *);          /* 函数指针，回调函数 */
void *arg;                          /* 上面函数的参数 */
</code></pre>
<p>} threadpool_task_t;                    &#x2F;* 各子线程任务结构体 *&#x2F;</p>
<p>rear &#x3D; 5 % 5</p>
<h3 id="线程池模块分析："><a href="#线程池模块分析：" class="headerlink" title="线程池模块分析："></a>线程池模块分析：</h3><pre><code>1. main();		

    创建线程池。

    向线程池中添加任务。 借助回调处理任务。

    销毁线程池。
</code></pre>
<p>​	<br>​	2. pthreadpool_create();<br>​	<br>        创建线程池结构体 指针。</p>
<pre><code>    初始化线程池结构体 &#123;  N 个成员变量 &#125;

    创建 N 个任务线程。

    创建 1 个管理者线程。

    失败时，销毁开辟的所有空间。（释放）

3. threadpool_thread（）

    进入子线程回调函数。

    接收参数 void *arg  --》 pool 结构体

    加锁 --》lock --》 整个结构体锁

    判断条件变量 --》 wait  -------------------170

4. adjust_thread（）

    循环 10 s 执行一次。

    进入管理者线程回调函数

    接收参数 void *arg  --》 pool 结构体

    加锁 --》lock --》 整个结构体锁

    获取管理线程池要用的到 变量。	task_num, live_num, busy_num

    根据既定算法，使用上述3变量，判断是否应该 创建、销毁线程池中 指定步长的线程。

5. threadpool_add ()

    总功能：

        模拟产生任务。   num[20]

        设置回调函数， 处理任务。  sleep（1） 代表处理完成。

    内部实现：

        加锁

        初始化 任务队列结构体成员。   回调函数 function， arg

        利用环形队列机制，实现添加任务。 借助队尾指针挪移 % 实现。

        唤醒阻塞在 条件变量上的线程。

        解锁

6.  从 3. 中的wait之后继续执行，处理任务。

    加锁
    
    获取 任务处理回调函数，及参数

    利用环形队列机制，实现处理任务。 借助队头指针挪移 % 实现。

    唤醒阻塞在 条件变量 上的 server。

    解锁

    加锁 

    改忙线程数++

    解锁

    执行处理任务的线程

    加锁 

    改忙线程数——

    解锁

7. 创建 销毁线程

    管理者线程根据 task_num, live_num, busy_num  

    根据既定算法，使用上述3变量，判断是否应该 创建、销毁线程池中 指定步长的线程。

    如果满足 创建条件

        pthread_create();   回调 任务线程函数。		live_num++

    如果满足 销毁条件

        wait_exit_thr_num = 10;  

        signal 给 阻塞在条件变量上的线程 发送 假条件满足信号    

        跳转至  --170 wait阻塞线程会被 假信号 唤醒。判断： wait_exit_thr_num  &gt; 0 pthread_exit();  
</code></pre>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TIME 10                 <span class="comment">/*10s检测一次*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_WAIT_TASK_NUM 10            <span class="comment">/*如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新的线程到线程池*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_THREAD_VARY 10          <span class="comment">/*每次创建和销毁线程的个数*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *(*function)(<span class="type">void</span> *);          <span class="comment">/* 函数指针，回调函数 */</span></span><br><span class="line">    <span class="type">void</span> *arg;                          <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="type">threadpool_task_t</span>;                    <span class="comment">/* 各子线程任务结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;               <span class="comment">/* 用于锁住本结构体 */</span>    </span><br><span class="line">    <span class="type">pthread_mutex_t</span> thread_counter;     <span class="comment">/* 记录忙状态线程个数de琐 -- busy_thr_num */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_full;      <span class="comment">/* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_empty;     <span class="comment">/* 任务队列里不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> *threads;                 <span class="comment">/* 存放线程池中每个线程的tid。数组 */</span></span><br><span class="line">    <span class="type">pthread_t</span> adjust_tid;               <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="type">threadpool_task_t</span> *task_queue;      <span class="comment">/* 任务队列(数组首地址) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min_thr_num;                    <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="type">int</span> max_thr_num;                    <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="type">int</span> live_thr_num;                   <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="type">int</span> busy_thr_num;                   <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="type">int</span> wait_exit_thr_num;              <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queue_front;                    <span class="comment">/* task_queue队头下标 */</span></span><br><span class="line">    <span class="type">int</span> queue_rear;                     <span class="comment">/* task_queue队尾下标 */</span></span><br><span class="line">    <span class="type">int</span> queue_size;                     <span class="comment">/* task_queue队中实际任务数 */</span></span><br><span class="line">    <span class="type">int</span> queue_max_size;                 <span class="comment">/* task_queue队列可容纳任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown;                       <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">threadpool_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">adjust_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_thread_alive</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_free</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//threadpool_create(3,100,100);  </span></span><br><span class="line"><span class="type">threadpool_t</span> *<span class="title function_">threadpool_create</span><span class="params">(<span class="type">int</span> min_thr_num, <span class="type">int</span> max_thr_num, <span class="type">int</span> queue_max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">threadpool_t</span> *pool = <span class="literal">NULL</span>;          <span class="comment">/* 线程池 结构体 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((pool = (<span class="type">threadpool_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">threadpool_t</span>))) == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;                                      <span class="comment">/*跳出do while*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;min_thr_num = min_thr_num;</span><br><span class="line">        pool-&gt;max_thr_num = max_thr_num;</span><br><span class="line">        pool-&gt;busy_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;live_thr_num = min_thr_num;               <span class="comment">/* 活着的线程数 初值=最小线程数 */</span></span><br><span class="line">        pool-&gt;wait_exit_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_size = <span class="number">0</span>;                           <span class="comment">/* 有0个产品 */</span></span><br><span class="line">        pool-&gt;queue_max_size = queue_max_size;          <span class="comment">/* 最大任务队列数 */</span></span><br><span class="line">        pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_rear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;shutdown = <span class="literal">false</span>;                         <span class="comment">/* 不关闭线程池 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */</span></span><br><span class="line">        pool-&gt;threads = (<span class="type">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max_thr_num); </span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threads fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threads, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max_thr_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给 任务队列 开辟空间 */</span></span><br><span class="line">        pool-&gt;task_queue = (<span class="type">threadpool_task_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">threadpool_task_t</span>)*queue_max_size);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;task_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc task_queue fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化互斥琐、条件变量 */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;(pool-&gt;lock), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_mutex_init(&amp;(pool-&gt;thread_counter), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_empty), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_full), <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;init the lock or cond fail&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 启动 min_thr_num 个 work thread */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min_thr_num; i++) &#123;</span><br><span class="line">            pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="type">void</span> *)pool);   <span class="comment">/*pool指向当前线程池*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;start thread 0x%x...\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pool-&gt;threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_create(&amp;(pool-&gt;adjust_tid), <span class="literal">NULL</span>, adjust_thread, (<span class="type">void</span> *)pool);     <span class="comment">/* 创建管理者线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    threadpool_free(pool);      <span class="comment">/* 前面代码调用失败时，释放poll存储空间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向线程池中 添加一个任务 */</span></span><br><span class="line"><span class="comment">//threadpool_add(thp, process, (void*)&amp;num[i]);   /* 向线程池中添加任务 process: 小写----&gt;大写*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_add</span><span class="params">(<span class="type">threadpool_t</span> *pool, <span class="type">void</span>*(*function)(<span class="type">void</span> *arg), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ==为真，队列已经满， 调wait阻塞 */</span></span><br><span class="line">    <span class="keyword">while</span> ((pool-&gt;queue_size == pool-&gt;queue_max_size) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;(pool-&gt;queue_not_full), &amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清空 工作线程 调用的回调函数 的参数arg */</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue[pool-&gt;queue_rear].arg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pool-&gt;task_queue[pool-&gt;queue_rear].arg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*添加任务到任务队列里*/</span></span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].function = function;</span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].arg = arg;</span><br><span class="line">    pool-&gt;queue_rear = (pool-&gt;queue_rear + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 队尾指针移动, 模拟环形 */</span></span><br><span class="line">    pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/</span></span><br><span class="line">    pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程池中各个工作线程 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">threadpool_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">threadpool_t</span> *pool = (<span class="type">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="type">threadpool_task_t</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* Lock must be taken to wait on conditional variable */</span></span><br><span class="line">        <span class="comment">/*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/</span></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while*/</span></span><br><span class="line">        <span class="keyword">while</span> ((pool-&gt;queue_size == <span class="number">0</span>) &amp;&amp; (!pool-&gt;shutdown)) &#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is waiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">            pthread_cond_wait(&amp;(pool-&gt;queue_not_empty), &amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;wait_exit_thr_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;wait_exit_thr_num--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*如果线程池里线程个数大于最小值时可以结束当前线程*/</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">                    pool-&gt;live_thr_num--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*如果指定了true，要关闭线程池里的每个线程，自行退出处理---销毁线程池*/</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">            pthread_detach(pthread_self());</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);     <span class="comment">/* 线程自行结束 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*从任务队列里获取任务, 是一个出队操作*/</span></span><br><span class="line">        task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">        task.arg = pool-&gt;task_queue[pool-&gt;queue_front].arg;</span><br><span class="line"></span><br><span class="line">        pool-&gt;queue_front = (pool-&gt;queue_front + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 出队，模拟环形队列 */</span></span><br><span class="line">        pool-&gt;queue_size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*通知可以有新的任务添加进来*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_full));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务取出后，立即将 线程池琐 释放*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*执行任务*/</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x start working\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));                            <span class="comment">/*忙状态线程数变量琐*/</span></span><br><span class="line">        pool-&gt;busy_thr_num++;                                                   <span class="comment">/*忙状态线程数+1*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        (*(task.function))(task.arg);                                           <span class="comment">/*执行回调函数任务*/</span></span><br><span class="line">        <span class="comment">//task.function(task.arg);                                              /*执行回调函数任务*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*任务结束处理*/</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x end working\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pool-&gt;busy_thr_num--;                                       <span class="comment">/*处理掉一个任务，忙状态数线程数-1*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理线程 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">adjust_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">threadpool_t</span> *pool = (<span class="type">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="keyword">while</span> (!pool-&gt;shutdown) &#123;</span><br><span class="line"></span><br><span class="line">        sleep(DEFAULT_TIME);                                    <span class="comment">/*定时 对线程池管理*/</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="type">int</span> queue_size = pool-&gt;queue_size;                      <span class="comment">/* 关注 任务数 */</span></span><br><span class="line">        <span class="type">int</span> live_thr_num = pool-&gt;live_thr_num;                  <span class="comment">/* 存活 线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        <span class="type">int</span> busy_thr_num = pool-&gt;busy_thr_num;                  <span class="comment">/* 忙着的线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建新线程 算法： 任务数大于最小线程池个数, 且存活的线程数少于最大线程个数时 如：30&gt;=10 &amp;&amp; 40&lt;100*/</span></span><br><span class="line">        <span class="keyword">if</span> (queue_size &gt;= MIN_WAIT_TASK_NUM &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));  </span><br><span class="line">            <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*一次增加 DEFAULT_THREAD 个线程*/</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;max_thr_num &amp;&amp; add &lt; DEFAULT_THREAD_VARY</span><br><span class="line">                    &amp;&amp; pool-&gt;live_thr_num &lt; pool-&gt;max_thr_num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threads[i] == <span class="number">0</span> || !is_thread_alive(pool-&gt;threads[i])) &#123;</span><br><span class="line">                    pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="type">void</span> *)pool);</span><br><span class="line">                    add++;</span><br><span class="line">                    pool-&gt;live_thr_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/</span></span><br><span class="line">        <span class="keyword">if</span> ((busy_thr_num * <span class="number">2</span>) &lt; live_thr_num  &amp;&amp;  live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_VARY;      <span class="comment">/* 要销毁的线程数 设置为10 */</span></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEFAULT_THREAD_VARY; i++) &#123;</span><br><span class="line">                <span class="comment">/* 通知处在空闲状态的线程, 他们会自行终止*/</span></span><br><span class="line">                pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_destroy</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pool-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*先销毁管理线程*/</span></span><br><span class="line">    pthread_join(pool-&gt;adjust_tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        <span class="comment">/*通知所有的空闲线程*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        pthread_join(pool-&gt;threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    threadpool_free(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_free</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threads) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_full));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_all_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> all_threadnum = <span class="number">-1</span>;                 <span class="comment">// 总线程数</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">    all_threadnum = pool-&gt;live_thr_num;     <span class="comment">// 存活线程数</span></span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_busy_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> busy_threadnum = <span class="number">-1</span>;                <span class="comment">// 忙线程数</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    busy_threadnum = pool-&gt;busy_thr_num;    </span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> busy_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_thread_alive</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> kill_rc = pthread_kill(tid, <span class="number">0</span>);     <span class="comment">//发0号信号，测试线程是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (kill_rc == ESRCH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程池中的线程，模拟处理业务 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">process</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x working on task %d\n &quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)pthread_self(),(<span class="type">int</span>)arg);</span><br><span class="line">    sleep(<span class="number">1</span>);                           <span class="comment">//模拟 小---大写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task %d is end\n&quot;</span>,(<span class="type">int</span>)arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">threadpool_t</span> *thp = threadpool_create(<span class="number">3</span>,<span class="number">100</span>,<span class="number">100</span>);   <span class="comment">/*创建线程池，池里最小3个线程，最大100，队列最大100*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pool inited&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int *num = (int *)malloc(sizeof(int)*20);</span></span><br><span class="line">    <span class="type">int</span> num[<span class="number">20</span>], i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        num[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>,i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg) */</span></span><br><span class="line"></span><br><span class="line">        threadpool_add(thp, process, (<span class="type">void</span>*)&amp;num[i]);   <span class="comment">/* 向线程池中添加任务 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>);                                          <span class="comment">/* 等子线程完成任务 */</span></span><br><span class="line">    threadpool_destroy(thp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>好再空过去看了也记不住</p>
<p>92-98</p>
<h2 id="TCP通信和UDP通信各自的优缺点："><a href="#TCP通信和UDP通信各自的优缺点：" class="headerlink" title="TCP通信和UDP通信各自的优缺点："></a>TCP通信和UDP通信各自的优缺点：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TCP：	面向连接的，可靠数据包传输。对于不稳定的网络层，采取完全弥补的通信方式。 丢包重传。</span><br><span class="line">	优点：</span><br><span class="line">		稳定。		</span><br><span class="line">			数据流量稳定、速度稳定、顺序也不变</span><br><span class="line">			电脑A通过TCP协议与电脑B进行数据通信时，在第一次进行通信时通过路由寻路，在互联网中探索出一条通路，如果网络环境不发生变化，这条路之后就不变了，数据包都按照这个路径发送			</span><br><span class="line">	缺点：</span><br><span class="line">		传输速度慢。效率低。开销大。</span><br><span class="line">	使用场景：数据的完整型要求较高，不追求效率。</span><br><span class="line">		  典型的大数据传输、文件传输。比如迅雷可以断点续传，（注意网络下载虽然不支持网络传输，但是它是TCP传输的，只是没有保存上一次的路径）</span><br></pre></td></tr></table></figure>

<p>​		  一般中小型企业选择TCP，在数据完整性的基础上，只需要增大服务器的处理能力就能达到需求，但是TCP协议用到极致也不会提高多少，所以大型企业还是用UDP进行通讯<br>​		  ![1708852255296](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1708852255296.png)</p>
<pre><code>UDP：	无连接的，不可靠的数据报传递。对于不稳定的网络层，采取完全不弥补的通信方式。 默认还原网络状况
</code></pre>
<p>​	<br>​		优点：<br>​	<br>            传输速度块。效率高。开销小。</p>
<pre><code>    缺点：
        不稳定。
            数据流量。速度。顺序。
            UDP在发送时会根据网络状况动态的去选择路由节点进行巡逻，不同的包发送路径不同


    使用场景：对时效性要求较高场合。稳定性其次。

          游戏、视频会议、视频电话。		腾讯、华为、阿里  ---  应用层数据校验协议，弥补udp的不足。
</code></pre>
<h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><p>![1708852255296](D:\Program Files (x86)\MyBlog\source_posts\网络编程\图片4.png)</p>
<h3 id="UDP实现的-C-S-模型："><a href="#UDP实现的-C-S-模型：" class="headerlink" title="UDP实现的 C&#x2F;S 模型："></a>UDP实现的 C&#x2F;S 模型：</h3><pre><code>recv()/send() 只能用于 TCP 通信。 替代 read、write

accpet(); ---- Connect(); ---被舍弃

server：

    lfd = socket(AF_INET, STREAM, 0);	SOCK_DGRAM --- 报式协议。

    bind();

    listen();  --- 可有可无

    while（1）&#123;

        read(cfd, buf, sizeof) --- 被替换 --- recvfrom（） --- 涵盖accept传出地址结构。

            ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);

                sockfd： 套接字

                buf：缓冲区地址

                len：缓冲区大小

                flags： 0

                src_addr：（struct sockaddr *）&amp;addr 传出。 对端地址结构

                addrlen：传入传出。

            返回值： 成功接收数据字节数。 失败：-1 errn。 0： 对端关闭。

        小-- 大
        write();--- 被替换 --- sendto（）---- connect

                 ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);

                    sockfd： 套接字

                    buf：存储数据的缓冲区

                    len：数据长度

                    flags： 0

                    src_addr：（struct sockaddr *）&amp;addr 传入。 目标地址结构

                    addrlen：地址结构长度。

                返回值：成功写出数据字节数。 失败 -1， errno		
        &#125;

        close();
    client：

        connfd = socket(AF_INET, SOCK_DGRAM, 0);

        sendto（‘服务器的地址结构’， 地址结构大小）

        recvfrom（）

        写到屏幕

        close();
</code></pre>
<h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8000  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span>  </span><br><span class="line">    <span class="type">socklen_t</span> clie_addr_len;  </span><br><span class="line">    <span class="type">int</span> sockfd;  </span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];  </span><br><span class="line">    <span class="type">char</span> str[INET_ADDRSTRLEN];  </span><br><span class="line">    <span class="type">int</span> i, n;  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));  </span><br><span class="line">    serv_addr.sin_family = AF_INET;  </span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  </span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);  </span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ,<span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clie_addr, &amp;clie_addr_len);  </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)  </span><br><span class="line">            perror(<span class="string">&quot;recvfrom error&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,  </span><br><span class="line">                inet_ntop(AF_INET, &amp;clie_addr.sin_addr, str, <span class="keyword">sizeof</span>(str)),  </span><br><span class="line">                ntohs(clie_addr.sin_port));  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);  </span><br><span class="line">  </span><br><span class="line">        n = sendto(sockfd, buf, n, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));  </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)  </span><br><span class="line">            perror(<span class="string">&quot;sendto error&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8000  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>  </span><br><span class="line">    <span class="type">int</span> sockfd, n;  </span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];  </span><br><span class="line">  </span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr);  </span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);  </span><br><span class="line">  </span><br><span class="line">    bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUFSIZ, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        n = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)  </span><br><span class="line">            perror(<span class="string">&quot;sendto error&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        n = recvfrom(sockfd, buf, BUFSIZ, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);         <span class="comment">//NULL:不关心对端信息  </span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)  </span><br><span class="line">            perror(<span class="string">&quot;recvfrom error&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        write(STDOUT_FILENO, buf, n);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="本地套接字和网络套接字"><a href="#本地套接字和网络套接字" class="headerlink" title="本地套接字和网络套接字"></a>本地套接字和网络套接字</h2><p><img src="/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1527923816604.png" alt="1527923816604"></p>
<h2 id="IPC通信："><a href="#IPC通信：" class="headerlink" title="IPC通信："></a>IPC通信：</h2><blockquote>
<p>管道pipe：易用性最强</p>
<p>有名管道fifo：可以在没有血缘关系的进程之间进行通信</p>
<p>共享内存映射mmap:可以在没有血缘关系的进程之间进行通信并且可以反复读取</p>
<p>信号:开销最小的</p>
<p>本地套接字(domain)：稳定性最好  ——是用CS模型实现本地套接字来实现进程间通讯</p>
</blockquote>
<p>本地套接字对比网络编程 TCP C&#x2F;S模型，就是服务器和客户端分别生成一个套接字文件，相互连接进行通讯。这个套接字文件是伪文件，它不占用磁盘大小，是通过调用bind函数创建出来的</p>
<h2 id="网络通信："><a href="#网络通信：" class="headerlink" title="网络通信："></a><strong>网络通信</strong>：</h2><ol>
<li>多进程：也就是为每个客户端分配一个进程来处理请求(记得回收子进程)</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/28009832/1686829237044-def92cbb-8132-46ba-8933-e67a6eff4278.png" alt="img"></p>
<ol>
<li>多线程：当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</li>
</ol>
<p>为每个请求分配一个进程&#x2F;线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 <strong>I&#x2F;O 多路复用</strong>技术：</p>
<ol>
<li>select&#x2F;poll：存在缺点–当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。</li>
<li>epoll：很好的解决了 select&#x2F;poll 的问题</li>
</ol>
<ul>
<li>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select&#x2F;poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</li>
<li>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select&#x2F;poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</li>
</ul>
<h2 id="Libevent库"><a href="#Libevent库" class="headerlink" title="Libevent库"></a>Libevent库</h2><h3 id="本地套接字对比网络编程-TCP-C-S模型"><a href="#本地套接字对比网络编程-TCP-C-S模型" class="headerlink" title="本地套接字对比网络编程 TCP C&#x2F;S模型"></a>本地套接字对比网络编程 TCP C&#x2F;S模型</h3><p> 注意以下几点：</p>
<pre><code>1. int socket(int domain, int type, int protocol); 
参数 domain：AF_INET --&gt; AF_UNIX/AF_LOCAL 
type: SOCK_STREAM/SOCK_DGRAM  都可以。	
2. bind() 地址结构：  sockaddr_in --&gt; sockaddr_un

    struct sockaddr_in srv_addr; --&gt; struct sockaddr_un srv_adrr;

    srv_addr.sin_family = AF_INET;  --&gt; srv_addr.sun_family = AF_UNIX;
    srv_addr.sin_port = htons(8888);    strcpy(srv_addr.sun_path, &quot;srv.socket&quot;) 
    由于不需要网络通信了，也不需要ip地址和端口号，这是在本地生成一个套接字，名称是 &quot;srv.socket&quot;，位置在srv_addr.sun_path是默认的
    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);			len = offsetof(struct sockaddr_un, sun_path) + strlen(&quot;srv.socket&quot;);
    bind(fd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr));  --&gt; 	bind(fd, (struct sockaddr *)&amp;srv_addr, len); 
    此时结构体的大小不再用sizeof计算，len = offsetof(struct sockaddr_un, sun_path) + strlen(&quot;srv.socket&quot;);
</code></pre>
<p>由于sock_addr数据结构：现在用的是第三个sockaddr_un，求大小的时候是加上地址便宜，后面的108字节路径名就是”srv.socket”。</p>
<p>​	![1708852255296](D:\Program Files (x86)\MyBlog\source_posts\网络编程\图片5.png)</p>
<pre><code>3. bind()函数调用成功，会创建一个 socket。因此为保证bind成功，通常我们在 bind之前， 可以使用 unlink(&quot;srv.socket&quot;);  这个函数是将个文件的硬连接计数-1，是为了能够顺利创建&quot;srv.socket&quot;文件，就先删一下&quot;srv.socket&quot;文件保证创建成功


4. 客户端不能依赖 “隐式绑定”。并且应该在通信建立过程中，创建且初始化2个地址结构：

    1） client_addr --&gt; bind()

    2)  server_addr --&gt; connect();
    （这两个地址结构分别根据之前定义的两个socket名绑定对应的文件）
</code></pre>
<p>​               </p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="服务器代码："><a href="#服务器代码：" class="headerlink" title="服务器代码："></a>服务器代码：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_ADDR  <span class="string">&quot;serv.socket&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> lfd, cfd, len, size, i;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span>  </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];  </span><br><span class="line">lfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">servaddr.sun_family = AF_UNIX;  </span><br><span class="line"><span class="built_in">strcpy</span>(servaddr.sun_path, SERV_ADDR);  </span><br><span class="line">  </span><br><span class="line">len = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">/* servaddr total len */</span>  </span><br><span class="line">  </span><br><span class="line">unlink(SERV_ADDR);                              <span class="comment">/* 确保bind之前serv.sock文件不存在,bind会创建该文件 */</span>  </span><br><span class="line">Bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, len);           <span class="comment">/* 参3不能是sizeof(servaddr) */</span>  </span><br><span class="line">  </span><br><span class="line">Listen(lfd, <span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Accept ...\n&quot;</span>);  </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">    len = <span class="keyword">sizeof</span>(cliaddr);  <span class="comment">//AF_UNIX大小+108B  </span></span><br><span class="line">  </span><br><span class="line">    cfd = Accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, (<span class="type">socklen_t</span> *)&amp;len);  </span><br><span class="line">  </span><br><span class="line">    len -= offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path);      <span class="comment">/* 得到文件名的长度 */</span>  </span><br><span class="line">    cliaddr.sun_path[len] = <span class="string">&#x27;\0&#x27;</span>;                       <span class="comment">/* 确保打印时,没有乱码出现 */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client bind filename %s\n&quot;</span>, cliaddr.sun_path);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> ((size = read(cfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)  </span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);  </span><br><span class="line">        write(cfd, buf, size);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(cfd);  </span><br><span class="line">&#125;  </span><br><span class="line">close(lfd);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>           </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_ADDR <span class="string">&quot;serv.socket&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIE_ADDR <span class="string">&quot;clie.socket&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span>  cfd, len;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span>  </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];  </span><br><span class="line">cfd = Socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">bzero(&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));  </span><br><span class="line">cliaddr.sun_family = AF_UNIX;  </span><br><span class="line"><span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);  </span><br><span class="line">  </span><br><span class="line">len = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);     <span class="comment">/* 计算客户端地址结构有效长度 */</span>  </span><br><span class="line">  </span><br><span class="line">unlink(CLIE_ADDR);  </span><br><span class="line">Bind(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, len);                                 <span class="comment">/* 客户端也需要bind, 不能依赖自动绑定*/</span> </span><br><span class="line">bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));                                          <span class="comment">/* 构造server 地址 */</span>  </span><br><span class="line">servaddr.sun_family = AF_UNIX;  </span><br><span class="line"><span class="built_in">strcpy</span>(servaddr.sun_path, SERV_ADDR);  </span><br><span class="line">  </span><br><span class="line">len = offsetof(<span class="keyword">struct</span> sockaddr_un, sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">/* 计算服务器端地址结构有效长度 */</span>  </span><br><span class="line">  </span><br><span class="line">Connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, len);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">    write(cfd, buf, <span class="built_in">strlen</span>(buf));  </span><br><span class="line">    len = read(cfd, buf, <span class="keyword">sizeof</span>(buf));  </span><br><span class="line">    write(STDOUT_FILENO, buf, len);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">close(cfd);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>对比本地套接字和网络套接字</p>
<p>![1709000247505](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1709000247505.png)</p>
<p>​	![1709000229274](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1709000229274.png)</p>
<h2 id="libevent库"><a href="#libevent库" class="headerlink" title="libevent库"></a>libevent库</h2><pre><code>开源。精简。跨平台（Windows、Linux、maxos、unix）。专注于网络通信。
</code></pre>
<p>源码包安装：  </p>
<h3 id="参考-README、readme"><a href="#参考-README、readme" class="headerlink" title="参考 README、readme"></a>参考 README、readme</h3><pre><code>./configure		检查安装环境 生成 makefile

make			生成 .o 和 可执行文件

sudo make install	将必要的资源cp至系统指定目录。

进入 sample 目录，运行demo验证库安装使用情况。

编译使用库的 .c 时，需要加 -levent 选项。不然会出现未定义的引用，因此需要建立软连接 将缺的那个库添加到默认库的文件夹下。建立动态库应该是libevent.so，静态库应该是libevent.a，在连接的时候需要指定库名，去掉lib前缀，去掉.so后缀 event

库名 libevent.so --&gt; /usr/local/lib   查看的到。
</code></pre>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><p>​	基于“事件”异步通信模型。— 回调。	</p>
<p>事件就是这个库名event，它在里边把所有的东西全部封装成事件（<code>struct event event_new();event_init() </code>)，所见皆事件。之前说的linux系统是所有东西都是文件，所见皆文件</p>
<h4 id="同步-异步通信模型"><a href="#同步-异步通信模型" class="headerlink" title="同步&#x2F;异步通信模型"></a>同步&#x2F;异步通信模型</h4><p>同步通信模型：有时效性的，并行的去访问，为了防止数据错乱需要安排先后顺序</p>
<p>异步通信模型：异步通信主要依赖回调机制。</p>
<p>​							函数的编写时机和调用时机不是同一时间的，当封装好了一个函数放在这里，这个函数不是							我封装事件或者代码满足条件的时候（阻塞或者if语句？）去执行，只有在某个条件到达的时							候才会执行这个代码。这个代码是内核调用的。</p>
<p>类似于信号捕捉，只要把函数注册上，只要条件满足了这个回调函数就自动被调用了，函数注册的时间和函数调用的时间不是一个时间</p>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><h3 id="未决和非未决："><a href="#未决和非未决：" class="headerlink" title="未决和非未决："></a>未决和非未决：</h3><pre><code>非未决: 没有资格被处理（前期准备条件都已经准备完了，就等着事件被触发

未决： 有资格被处理，但尚未被处理（还没有准备好，即使事件被触发了也没有被触发的机会

event_new --&gt; event ---&gt; 非未决 --&gt; event_add --&gt; 未决 --&gt; dispatch() &amp;&amp; 监听事件被触发 --&gt; 激活态 

--&gt; 执行回调函数 --&gt; 处理态 --&gt; 非未决 event_add &amp;&amp; EV_PERSIST --&gt; 未决 --&gt; event_del --&gt; 非未决
</code></pre>
<p>![1709035249826](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1709035249826.png)</p>
<h3 id="带缓冲区的事件-bufferevent"><a href="#带缓冲区的事件-bufferevent" class="headerlink" title="带缓冲区的事件 bufferevent"></a>带缓冲区的事件 bufferevent</h3><pre><code>#include &lt;event2/bufferevent.h&gt; 

read/write 两个缓冲. 借助 队列.

原理:bufferevent有两个缓冲区∶也是队列实现，读走没，先进先出。
读︰有数据--&gt;读回调函数被调用--&gt;使用bufferevent_read() --&gt;读数据。
写∶使用bufferevent_write() --&gt;向写缓冲中写数据--&gt;该缓冲区有数据自动写出--&gt;写完，回调函数被调用（鸡肋)。
</code></pre>
<p>buf是一个结构体</p>
<p>![1709036653944](D:\Program Files (x86)\MyBlog\source_posts\网络编程\1709036653944.png)</p>
<h3 id="bufferevent相关函数"><a href="#bufferevent相关函数" class="headerlink" title="bufferevent相关函数"></a>bufferevent相关函数</h3><p>空</p>
<h3 id="启动和关闭缓冲区"><a href="#启动和关闭缓冲区" class="headerlink" title="启动和关闭缓冲区"></a>启动和关闭缓冲区</h3><p>因为套接字里面要求缓冲区可以双向全双工和半关闭</p>
<p>而bufferevent打造出来的缓冲区相当于fd（套接字）也封装到它的内部，它的read和write也支持半关闭</p>
<h2 id="web大练习"><a href="#web大练习" class="headerlink" title="web大练习"></a>web大练习</h2><p>借助浏览器和自己电脑上的服务器完成一些通信</p>
<p>自己的服务器上的一个文件夹里有一些文件，可以从浏览器上通过域名解析得到ip（公网ip)地址和端口号进行访问，但是公网ip要申请，所以还是用局域网，127.0.0.1这个</p>
<h3 id="准备工作：html语言"><a href="#准备工作：html语言" class="headerlink" title="准备工作：html语言"></a>准备工作：html语言</h3><p>前端，搭建网页</p>
<h3 id="http超文本传输协议"><a href="#http超文本传输协议" class="headerlink" title="http超文本传输协议"></a>http超文本传输协议</h3><p>请求协议</p>
<p>![1709036653944](D:\Program Files (x86)\MyBlog\source_posts\网络编程\图片6.png)</p>
<p>应答协议</p>
<p>![1709036653944](D:\Program Files (x86)\MyBlog\source_posts\网络编程\图片7.png)</p>
<p>实现思路：</p>
<p>与高并发服务器类似</p>
<p>只是在得到cfd之后的read阶段，read的内容是http请求头，而且对象也是一个文件描述符，如果读一行对象是文件的话可以用fget()函数，但是这是文件描述符，我们根据read()函数自己写了封装了一个readline()函数，但是他默认的是在linux系统下读取文件描述符对应的文件，这个文件以\n结尾，但是http是\r\n</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#day1%E7%AC%94%E8%AE%B0"><span class="toc-number">1.1.</span> <span class="toc-text">day1笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket"><span class="toc-number">1.2.</span> <span class="toc-text">socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">四次握手  断开连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">三次握手与函数的对应关系：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8ETCP%E7%8A%B6%E6%80%81%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.2.4.</span> <span class="toc-text">三次握手四次挥手与TCP状态对应关系：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%EF%BC%9A"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">端口复用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E5%8C%85%EF%BC%9A"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">心跳包：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E5%85%B3%E9%97%AD%E7%AB%AF%E7%9A%842MSL%E6%97%B6%E9%95%BF%EF%BC%9A"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">主动关闭端的2MSL时长：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="toc-number">1.2.5.</span> <span class="toc-text">半关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#day2%E7%AC%94%E8%AE%B0"><span class="toc-number">1.3.</span> <span class="toc-text">day2笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">多路IO转接（响应式）服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">select函数实现响应式服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">select函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%9B%86%E5%90%88%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">设置集合的函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">思路分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">select实现代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">select优缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#day3%E7%AC%94%E8%AE%B0"><span class="toc-number">1.5.</span> <span class="toc-text">day3笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#poll%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">poll函数实现响应式服务器（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">poll函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">思路分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">poll实现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">poll优缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%81%E7%A0%B4-1024-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6%EF%BC%9A"><span class="toc-number">1.5.1.4.1.</span> <span class="toc-text">突破 1024 文件描述符限制：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">epoll函数实现响应式服务器（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">epoll函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">epoll实现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E7%9A%84%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">epoll的触发模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readn%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">readn阻塞：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%A6%81%E5%9C%A8ET%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8fcntl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-number">1.5.2.5.1.</span> <span class="toc-text">如果要在ET的情况下用fcntl函数实现非阻塞：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-number">1.5.2.5.1.1.</span> <span class="toc-text">设置阻塞非阻塞：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">epoll优缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">epoll反应堆模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#day4%E7%AC%94%E8%AE%B0"><span class="toc-number">1.6.</span> <span class="toc-text">day4笔记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.7.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.7.1.</span> <span class="toc-text">线程池的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">线程池相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.7.3.</span> <span class="toc-text">线程池模块分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.7.4.</span> <span class="toc-text">实现代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E5%92%8CUDP%E9%80%9A%E4%BF%A1%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.8.</span> <span class="toc-text">TCP通信和UDP通信各自的优缺点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1"><span class="toc-number">1.9.</span> <span class="toc-text">UDP通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%AE%9E%E7%8E%B0%E7%9A%84-C-S-%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.9.1.</span> <span class="toc-text">UDP实现的 C&#x2F;S 模型：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">服务器代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">客户端代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.10.</span> <span class="toc-text">本地套接字和网络套接字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPC%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">1.11.</span> <span class="toc-text">IPC通信：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">1.12.</span> <span class="toc-text">网络通信：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Libevent%E5%BA%93"><span class="toc-number">1.13.</span> <span class="toc-text">Libevent库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AF%B9%E6%AF%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-TCP-C-S%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.13.1.</span> <span class="toc-text">本地套接字对比网络编程 TCP C&#x2F;S模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">1.13.2.</span> <span class="toc-text">实现代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">服务器代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">客户端代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libevent%E5%BA%93"><span class="toc-number">1.14.</span> <span class="toc-text">libevent库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-README%E3%80%81readme"><span class="toc-number">1.14.1.</span> <span class="toc-text">参考 README、readme</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.14.2.</span> <span class="toc-text">特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">同步&#x2F;异步通信模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">函数指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%86%B3%E5%92%8C%E9%9D%9E%E6%9C%AA%E5%86%B3%EF%BC%9A"><span class="toc-number">1.14.3.</span> <span class="toc-text">未决和非未决：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BA%8B%E4%BB%B6-bufferevent"><span class="toc-number">1.14.4.</span> <span class="toc-text">带缓冲区的事件 bufferevent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bufferevent%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.5.</span> <span class="toc-text">bufferevent相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.14.6.</span> <span class="toc-text">启动和关闭缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%A4%A7%E7%BB%83%E4%B9%A0"><span class="toc-number">1.15.</span> <span class="toc-text">web大练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%9Ahtml%E8%AF%AD%E8%A8%80"><span class="toc-number">1.15.1.</span> <span class="toc-text">准备工作：html语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.15.2.</span> <span class="toc-text">http超文本传输协议</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&text="><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&is_video=false&description="><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=&body=Check out this article: https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&title="><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&name=&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://luccas0320.github.io/2024/02/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/&t="><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Luccas0320
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
